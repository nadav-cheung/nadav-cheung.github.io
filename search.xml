<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《优先队列 PriorityQueue》</title>
    <url>/posts/dbb3c5e/</url>
    <content><![CDATA[<h2 id="《算法与数据结构：优先队列PriorityQueue》"><a href="#《算法与数据结构：优先队列PriorityQueue》" class="headerlink" title="《算法与数据结构：优先队列PriorityQueue》"></a>《算法与数据结构：优先队列 PriorityQueue》</h2><h2 id="什么是优先队列？"><a href="#什么是优先队列？" class="headerlink" title="什么是优先队列？"></a>什么是优先队列？</h2><p>优先队列是一种特殊的队列，其核心特性在于队列中的元素是按照一定的优先级进行排序的，而不是按照它们进入队列的顺序。在优先队列中，元素被赋予一个优先级，当访问队列时，优先级最高的元素最先被删除。这种机制使得优先队列非常适用于那些需要快速访问最重要元素的场合。</p>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/202402201117648.jpg" alt="img"></p>
<p><strong>可以看到优先攻击目标有三个选项，当我们点击自动补刀时，游戏英雄就会按照相应的优先级进行攻击</strong></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><strong>动态排序</strong>：优先队列内部的元素会根据它们的优先级动态排序，确保每次出队的都是当前优先级最高的元素。</li>
<li><strong>高效性</strong>：通过使用高效的数据结构（如二叉堆），优先队列可以在对数时间复杂度内完成插入和删除最优元素的操作。</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><strong>任务调度</strong>：在操作系统中管理进程或任务的执行顺序。</li>
<li><strong>图算法</strong>：如在 Dijkstra 最短路径算法中选择下一个要访问的节点。</li>
<li><strong>事件驱动模拟</strong>：按事件优先级顺序处理模拟事件。</li>
</ul>
<span id="more"></span>

<h2 id="优先队列的工作原理"><a href="#优先队列的工作原理" class="headerlink" title="优先队列的工作原理"></a>优先队列的工作原理</h2><p>要理解优先队列是如何工作的，首先需要了解它背后最常用的数据结构 —— 二叉堆。</p>
<h3 id="二叉堆简介"><a href="#二叉堆简介" class="headerlink" title="二叉堆简介"></a>二叉堆简介</h3><p>二叉堆是一种完全二叉树，树中的每个节点都满足堆属性，即节点的键值大于等于（或小于等于）其子节点的键值。这种属性使得堆的根节点总是存储最大元素（在最大堆中）或最小元素（在最小堆中）。</p>
<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>当新元素被加入到优先队列时，它首先被插入到堆的末尾。随后，通过一系列上浮操作，该元素可能会上移至更靠近根部的位置，以维持堆的有序性。</p>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>删除操作通常涉及到移除根节点（即优先级最高的元素），然后将堆的最后一个元素移至根部，并通过下沉操作重新恢复堆的有序性。</p>
<h2 id="实现优先队列"><a href="#实现优先队列" class="headerlink" title="实现优先队列"></a>实现优先队列</h2><h3 id="PriorityQueue类"><a href="#PriorityQueue类" class="headerlink" title="PriorityQueue类"></a>PriorityQueue 类</h3><p>Java 的 PriorityQueue 类基于优先级堆实现，支持基本操作如插入、删除及查看优先级最高的元素。其泛型设计允许存储任意类型的对象，只要这些对象实现了 Comparable 接口，或者在创建队列时提供了一个 Comparator。</p>
<h3 id="使用最小堆实现优先队列"><a href="#使用最小堆实现优先队列" class="headerlink" title="使用最小堆实现优先队列"></a>使用最小堆实现优先队列</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 优先队列</span></span><br><span class="line"><span class="comment"> * 优先队列是一个基于优先级堆的无界队列。优先队列的元素按照其自然顺序进行排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityQueue</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> E&gt;&gt; <span class="keyword">implements</span> <span class="title class_">Queue</span>&lt;E&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要分配的数组的最大大小。</span></span><br><span class="line"><span class="comment">     * 一些虚拟机在数组中保留一些头字。尝试分配更大的数组可能会导致 OutOfMemoryError：</span></span><br><span class="line"><span class="comment">     * 请求的数组大小超出 VM 限制</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SOFT_MAX_ARRAY_LENGTH</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认初始容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">transient</span> Object[] elements;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个空优先队列，其初始容量足以容纳 11 个元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个具有指定初始容量的优先队列。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity 优先队列的初始容量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException 如果指定的初始容量为负</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(<span class="type">int</span> initialCapacity)</span> {</span><br><span class="line">        <span class="comment">// Note: This restriction of at least one is not actually needed,</span></span><br><span class="line">        <span class="comment">// but continues for 1.5 compatibility</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="built_in">this</span>.elements = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个数组堆化处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 带堆化的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(E[] nums)</span> {</span><br><span class="line">        initFromArray(nums);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensures that elementData[0] exists, helping peek() and poll().</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object[] ensureNonEmpty(Object[] nums) {</span><br><span class="line">        <span class="keyword">return</span> (nums.length &gt; <span class="number">0</span>) ? nums : <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在位置 k 处插入项 x，通过将 x 沿着树重复降级直到它小于或等于其子项或者是叶子来保持堆不变性。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">siftDownComparable</span><span class="params">(<span class="type">int</span> index, Object element, Object[] elements, <span class="type">int</span> length)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> length &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Comparable&lt;? <span class="built_in">super</span> E&gt; key = (Comparable&lt;? <span class="built_in">super</span> E&gt;) element;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; half) {</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> leftChild(index);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 两个孩子中的较小者</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">c</span> <span class="operator">=</span> elements[child];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 右边孩子节点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rightChildIndex</span> <span class="operator">=</span> child + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rightChildIndex &lt; length &amp;&amp;</span><br><span class="line">                    ((Comparable&lt;? <span class="built_in">super</span> E&gt;) c).compareTo((E) elements[rightChildIndex]) &gt; <span class="number">0</span>) {</span><br><span class="line">                c = elements[child = rightChildIndex];</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// key小于两个孩子节点 满足堆的性质</span></span><br><span class="line">            <span class="keyword">if</span> (key.compareTo((E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            elements[index] = c;</span><br><span class="line">            index = child;</span><br><span class="line">        }</span><br><span class="line">        elements[index] = key;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 左孩子节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent 父节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 左孩子节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">leftChild</span><span class="params">(<span class="type">int</span> parent)</span> {</span><br><span class="line">        <span class="keyword">return</span> parent &lt;&lt; <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">siftUpComparable</span><span class="params">(<span class="type">int</span> index, T element, Object[] elements)</span> {</span><br><span class="line">        Comparable&lt;? <span class="built_in">super</span> T&gt; key = (Comparable&lt;? <span class="built_in">super</span> T&gt;) element;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> parent(index);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">e</span> <span class="operator">=</span> elements[parent];</span><br><span class="line">            <span class="keyword">if</span> (key.compareTo((T) e) &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            elements[index] = e;</span><br><span class="line">            index = parent;</span><br><span class="line">        }</span><br><span class="line">        elements[index] = key;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 父节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 子节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 父节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">parent</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"index-0 doesn't have parent"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> (index - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个新的数组长度，以便将其传递给 Arrays.copyOf 方法。</span></span><br><span class="line"><span class="comment">     * 该长度应该是新数组的长度。</span></span><br><span class="line"><span class="comment">     * 该方法将计算新数组的长度，以便将其传递给 Arrays.copyOf 方法。</span></span><br><span class="line"><span class="comment">     * 该长度应该是新数组的长度。</span></span><br><span class="line"><span class="comment">     * 该方法将计算新数组的长度，以便将其传递给 Arrays.copyOf 方法。</span></span><br><span class="line"><span class="comment">     * 如果新长度不超过 MAX_ARRAY_LENGTH，则它将是新数组的长度。</span></span><br><span class="line"><span class="comment">     * 否则，如果旧长度小于 MAX_ARRAY_LENGTH，则新长度将是 MAX_ARRAY_LENGTH。</span></span><br><span class="line"><span class="comment">     * 否则，新长度将是 Integer.MAX_VALUE。</span></span><br><span class="line"><span class="comment">     * 参数：</span></span><br><span class="line"><span class="comment">     * oldLength - 旧数组的长度</span></span><br><span class="line"><span class="comment">     * minGrowth - 最小增长</span></span><br><span class="line"><span class="comment">     * prefGrowth - 首选增长</span></span><br><span class="line"><span class="comment">     * 返回：</span></span><br><span class="line"><span class="comment">     * 新数组的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">newLength</span><span class="params">(<span class="type">int</span> oldLength, <span class="type">int</span> minGrowth, <span class="type">int</span> prefGrowth)</span> {</span><br><span class="line">        <span class="comment">// preconditions not checked because of inlining</span></span><br><span class="line">        <span class="comment">// assert oldLength &gt;= 0</span></span><br><span class="line">        <span class="comment">// assert minGrowth &gt; 0</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">prefLength</span> <span class="operator">=</span> oldLength + Math.max(minGrowth, prefGrowth); <span class="comment">// might overflow</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &lt; prefLength &amp;&amp; prefLength &lt;= SOFT_MAX_ARRAY_LENGTH) {</span><br><span class="line">            <span class="keyword">return</span> prefLength;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// put code cold in a separate method</span></span><br><span class="line">            <span class="keyword">return</span> hugeLength(oldLength, minGrowth);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 边缘条件的容量计算，特别是溢出。</span></span><br><span class="line"><span class="comment">     * 参数：</span></span><br><span class="line"><span class="comment">     * oldLength - 旧数组的长度</span></span><br><span class="line"><span class="comment">     * minGrowth - 最小增长</span></span><br><span class="line"><span class="comment">     * 返回：</span></span><br><span class="line"><span class="comment">     * 新数组的长度</span></span><br><span class="line"><span class="comment">     * 抛出：</span></span><br><span class="line"><span class="comment">     * OutOfMemoryError - 如果新长度超出范围</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeLength</span><span class="params">(<span class="type">int</span> oldLength, <span class="type">int</span> minGrowth)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">minLength</span> <span class="operator">=</span> oldLength + minGrowth;</span><br><span class="line">        <span class="keyword">if</span> (minLength &lt; <span class="number">0</span>) { <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>(</span><br><span class="line">                    <span class="string">"Required array length "</span> + oldLength + <span class="string">" + "</span> + minGrowth + <span class="string">" is too large"</span>);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (minLength &lt;= SOFT_MAX_ARRAY_LENGTH) {</span><br><span class="line">            <span class="keyword">return</span> SOFT_MAX_ARRAY_LENGTH;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> minLength;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化堆的内存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 初始化传入的树组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initFromArray</span><span class="params">(E[] nums)</span> {</span><br><span class="line">        initElementsFromArray(nums);</span><br><span class="line">        heapify();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化堆的内存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 初始化传入的树组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initElementsFromArray</span><span class="params">(E[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (Object e : nums)</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="comment">// 确保已经初始化</span></span><br><span class="line">        <span class="built_in">this</span>.elements = ensureNonEmpty(nums);</span><br><span class="line">        <span class="built_in">this</span>.size = len;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Establishes the heap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">final</span> Object[] es = elements;</span><br><span class="line">        <span class="comment">// 容量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> size;</span><br><span class="line">        <span class="comment">// 最后一个非叶子节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (n &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            siftDownComparable(i, es[i], es, n);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回队列中的元素数。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 队列中的元素数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回队列中的元素数。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 队列中的元素数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 要添加的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果队列由于调整大小而更改，则为 true</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException 如果指定的元素为 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> {</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elements.length)</span><br><span class="line">            grow(i + <span class="number">1</span>);</span><br><span class="line">        siftUp(i, e);</span><br><span class="line">        size = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上浮操作</span></span><br><span class="line"><span class="comment">     * 在位置 k 处插入项 x，通过将 x 沿树向上提升直到它大于或等于其父项，或者是根，来保持堆不变性。</span></span><br><span class="line"><span class="comment">     * 与 siftDown 类似</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUp</span><span class="params">(<span class="type">int</span> k, E x)</span> {</span><br><span class="line">        siftUpComparable(k, x, elements);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Increases the capacity of the array.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        <span class="comment">// Double size if small; else grow by 50%</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newLength(oldCapacity,</span><br><span class="line">                minCapacity - oldCapacity, <span class="comment">/* minimum growth */</span></span><br><span class="line">                oldCapacity &lt; <span class="number">64</span> ? oldCapacity + <span class="number">2</span> : oldCapacity &gt;&gt; <span class="number">1</span></span><br><span class="line">                <span class="comment">/* preferred growth */</span>);</span><br><span class="line">        elements = Arrays.copyOf(elements, newCapacity);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts the specified element into this priority queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} (as specified by {<span class="doctag">@link</span> Queue#offer})</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException   if the specified element cannot be</span></span><br><span class="line"><span class="comment">     *                              compared with elements currently in this priority queue</span></span><br><span class="line"><span class="comment">     *                              according to the priority queue's ordering</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">final</span> Object[] es;</span><br><span class="line">        <span class="keyword">final</span> E result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((result = (E) ((es = elements)[<span class="number">0</span>])) != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> n;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> (E) es[(n = --size)];</span><br><span class="line">            es[n] = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">0</span>) {</span><br><span class="line">                siftDownComparable(<span class="number">0</span>, x, es, n);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Retrieves, but does not remove, the head of this queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the head of this queue, or {<span class="doctag">@code</span> null} if this queue is empty</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> (E) elements[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="优先队列的应用"><a href="#优先队列的应用" class="headerlink" title="优先队列的应用"></a>优先队列的应用</h2><p>优先队列的应用广泛，覆盖了从系统内核到高级应用程序的各个方面。</p>
<h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>在多任务操作系统中，优先队列可用于管理进程或线程的执行。系统根据任务的紧急程度、资源需求等因素确定任务的优先级，以确保关键任务能够获得优先处理。</p>
<h3 id="网络流量管理"><a href="#网络流量管理" class="headerlink" title="网络流量管理"></a>网络流量管理</h3><p>在网络路由器和交换机中，优先队列用于实现 QoS（服务质量）策略，确保高优先级的数据包（如实时视频流）可以优先传输。</p>
<h3 id="实时数据处理"><a href="#实时数据处理" class="headerlink" title="实时数据处理"></a>实时数据处理</h3><p>在金融市场、网络监控等领域，实时数据处理至关重要。优先队列可以帮助快速处理最重要的数据，从而做出及时的决策。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>优先队列是一种强大而灵活的数据结构，它在多个领域中发挥着重要作用。通过本文的介绍，我们不仅理解了优先队列的原理和实现，还了解了它在实际应用中的广泛用途。掌握优先队列，无疑会为我们解决复杂问题提供更多帮助。</p>
<h2 id="github项目"><a href="#github项目" class="headerlink" title="github项目"></a><a href="https://github.com/nadav-cheung/algorithm">github 项目</a></h2>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PriorityQueue</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>PriorityQueue</tag>
        <tag>优先队列</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>《Heap》</title>
    <url>/posts/5eb18949/</url>
    <content><![CDATA[<h2 id="《算法与数据结构-Heap》"><a href="#《算法与数据结构-Heap》" class="headerlink" title="《算法与数据结构:Heap》"></a>《算法与数据结构：Heap》</h2><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆是一种数据结构，它是一种完全二叉树，具有以下特点：</p>
<ol>
<li>堆是完全二叉树，即每个节点都有两个子节点。</li>
<li>堆是一种有序树，即对于任意节点 n，如果 n 有左子节点 l 和右子节点 r，则 n 的值比 l 和 r 的值都大或都小。</li>
<li>堆可以分为最大堆和最小堆两种，最大堆的根节点是堆中最大的元素，最小堆的根节点是堆中最小的元素。</li>
</ol>
<span id="more"></span>

<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-df0b5309a708f8effd4bffa213dfe5bb_r.jpg" alt="img"></p>
<h3 id="堆的特性"><a href="#堆的特性" class="headerlink" title="堆的特性"></a>堆的特性</h3><p>堆是一种特殊的树形数据结构。它满足两个主要特性：</p>
<ol>
<li><strong>结构性</strong>：堆是一棵完全二叉树，这意味着除了最后一层外，每一层都是完全填满的，而且最后一层的所有节点都尽可能地集中在左侧。</li>
<li><strong>堆属性</strong>：在最大堆中，任何一个父节点的值都大于或等于它的子节点；在最小堆中，则相反，父节点的值小于或等于其子节点。</li>
<li><strong>存储</strong>：堆可以用数组来存储。对于数组中的任意元素，其子节点和父节点的位置可以通过简单的数学运算得到。</li>
<li><strong>类型</strong>：堆主要有两种类型 —— 最大堆和最小堆。</li>
</ol>
<ul>
<li><strong>最大堆</strong>：每个父节点的值都大于或等于其子节点的值。</li>
<li><strong>最小堆</strong>：每个父节点的值都小于或等于其子节点的值。</li>
</ul>
<h3 id="堆（Heap）数据结构"><a href="#堆（Heap）数据结构" class="headerlink" title="堆（Heap）数据结构"></a><strong>堆（Heap）数据结构</strong></h3><p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-8be589c877e0c822d4edf42b5d53a379_1440w.png" alt="堆数据结构的数组表示"></p>
<h3 id="堆的应用"><a href="#堆的应用" class="headerlink" title="堆的应用"></a>堆的应用</h3><p>堆主要用于实现优先队列，并广泛用于各类算法中，如堆排序、图算法中的 Dijkstra 最短路径算法等。</p>
<h3 id="堆的操作"><a href="#堆的操作" class="headerlink" title="堆的操作"></a>堆的操作</h3><p>堆的主要操作有插入、删除和堆排序。堆的插入和删除操作的时间复杂度均为 O (logn)，其中 n 为堆中节点的数量。堆排序是将一个无序的数组转换成一个有序的数组合并进行排序的过程，时间复杂度为 O (nlogn)。</p>
<h2 id="堆的数组实现"><a href="#堆的数组实现" class="headerlink" title="堆的数组实现"></a><strong>堆的数组实现</strong></h2><p>在数组实现中，我们使用如下方法计算父节点和左右孩子节点之间的关系。</p>
<p>对于数组中任何位置 <code>i</code> 的元素：</p>
<p>它的父节点位置是 ：<br>$$<br>parent=(i-1)\div2,i&gt;0<br>$$<br>它的左子节点位置是:<br>$$<br>leftchild=i\times2+1<br>$$<br>它的右子节点位置是:<br>$$<br>rightchild=(i+1)\times2<br>$$<br><strong>从数据存储结构上来看，最大堆 / 最小堆是一个数组。</strong></p>
<p><strong>从数据逻辑结构来看，最大堆 / 堆小堆事一颗完全二叉树。</strong></p>
<p>siftUp 和 siftDown 是在堆数据结构中用于维护堆属性的两个重要操作。这两个操作确保在插入新元素或移除堆顶元素后，堆仍然保持其结构和性质。我们来具体探讨一下这两个操作的原理。</p>
<h3 id="siftUp-原理"><a href="#siftUp-原理" class="headerlink" title="siftUp 原理"></a><strong>siftUp</strong> <strong> 原理</strong></h3><p>siftUp（也称为上浮、上滤或泡上来）主要用于插入操作。当一个新元素被添加到堆的末端时，它可能会违反堆的性质。siftUp 的目的是重新调整元素的位置，以恢复堆的性质。</p>
<p><strong>1、过程:</strong></p>
<ul>
<li>将新元素添加到堆的末尾（即数组的最后一个位置）。</li>
<li>比较新元素与其父节点的值（在最小堆中，父节点的值应小于子节点）。</li>
<li>如果新元素的值小于其父节点的值，则交换这两个节点。</li>
<li>继续向上比较和交换，直到新元素的父节点的值小于或等于新元素，或者新元素已经到达堆顶（成为根节点）。</li>
</ul>
<p><strong>2、目的:</strong></p>
<ul>
<li>确保在将新元素添加到堆后，堆仍然保持最小堆（或最大堆，取决于堆的类型）的性质。</li>
</ul>
<h3 id="siftUp源码"><a href="#siftUp源码" class="headerlink" title="siftUp源码"></a>siftUp 源码</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上浮操作</span></span><br><span class="line"><span class="comment"> * 在位置 k 处插入项 x，通过将 x 沿树向上提升直到它大于或等于其父项，或者是根，来保持堆不变性。</span></span><br><span class="line"><span class="comment"> * 与 siftDown 类似</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUp</span><span class="params">(<span class="type">int</span> k, E x)</span> {</span><br><span class="line"> siftUpComparable(k, x, elementData);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>siftUp 具体实现</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">siftUpComparable</span><span class="params">(<span class="type">int</span> k, T x, Object[] es)</span> {</span><br><span class="line">    Comparable&lt;? <span class="built_in">super</span> T&gt; key = (Comparable&lt;? <span class="built_in">super</span> T&gt;) x;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> parent(k);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">e</span> <span class="operator">=</span> es[parent];</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((T) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        es[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    }</span><br><span class="line">    es[k] = key;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>过程</strong></p>
<p><strong>将新元素添加到堆的末尾（即完全二叉树的最后一个节点）。</strong></p>
<p><strong>比较这个新元素与其父节点的值。</strong></p>
<ul>
<li>在最大堆中，如果新元素大于其父节点，它们就交换位置。</li>
<li>在最小堆中，如果新元素小于其父节点，它们同样交换位置。</li>
</ul>
<p><strong>重复步骤 2，直到新元素到达堆顶，或者找到了合适的位置（即满足堆的性质）。</strong></p>
<h3 id="siftUp演示"><a href="#siftUp演示" class="headerlink" title="siftUp演示"></a>siftUp 演示</h3><p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-9a66f1cf4ce4e45851b3dbc997ff9d26_1440w.png" alt="img"></p>
<p><strong>插入元素 3，元素 3 开始上浮</strong></p>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-388ea94e5bdadb21bdd29a53929b1d37_1440w-20240202204626635.png" alt="img"></p>
<p><strong>元素 3 继续上浮至根节点</strong></p>
<h3 id="siftDown-原理"><a href="#siftDown-原理" class="headerlink" title="siftDown 原理"></a><strong>siftDown</strong> <strong> 原理</strong></h3><p>siftDown（也称为下沉、下滤或沉下去）通常用于移除操作。在移除堆顶元素后，通常会将堆的最后一个元素移动到堆顶，这可能会违反堆的性质。siftDown 的目的是重新调整元素的位置以恢复堆的性质。</p>
<p><strong>1、过程</strong>:</p>
<ul>
<li>在移除堆顶元素后，将堆的最后一个元素移动到堆顶。</li>
<li>比较新的堆顶元素与其子节点的值（在最小堆中，父节点的值应小于子节点）。</li>
<li>如果新堆顶的值大于任一子节点的值，则它与其最小的子节点交换位置。</li>
<li>继续向下比较和交换，直到新堆顶的值小于其所有子节点，或者它已经成为叶节点。</li>
</ul>
<p><strong>2、目的</strong>:</p>
<ul>
<li>确保在移除堆顶元素后，堆仍然保持最小堆（或最大堆）的性质。</li>
</ul>
<p><strong>以最小堆为例 展示 siftDown () 操作</strong></p>
<p><strong>从最后一个非叶子节点开始</strong>，沿着树重复降级直到它小于或等于其子项或者是叶子来保持堆不变性</p>
<h3 id="siftDown演示"><a href="#siftDown演示" class="headerlink" title="siftDown演示"></a>siftDown 演示</h3><p><strong>第一步，从第一个非叶子节点 index 为 2 值为 8 开始，执行 siftDown。</strong></p>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-0b57dd5b28996703664e661e4a1883af_1440w-20240202204639070.png" alt="img"></p>
<p><strong>第二步，index 为 1 值为 18，执行 siftDown</strong></p>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-99c060e314fb475e769eb45fdd636415_1440w-20240202204649414.png" alt="img">)</p>
<p><strong>第三步，index 为 0 值为 10，执行 siftDown</strong></p>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-cf908bb357fd1257530a305296e3f0ef_1440w.png" alt="img"></p>
<p><img data-src="https://pic1.zhimg.com/80/v2-4144de2e44314c448cc9f795bc4597b8_1440w.png?source=d16d100b" alt="img"></p>
<h3 id="siftDown源码"><a href="#siftDown源码" class="headerlink" title="siftDown源码"></a>siftDown 源码</h3><p>在位置 k 处插入项 x，通过将 x 沿着树重复降级直到它小于或等于其子项或者是叶子来保持堆不变性。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在位置 k 处插入项 x，通过将 x 沿着树重复降级直到它小于或等于其子项或者是叶子来保持堆不变性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">siftDownComparable</span><span class="params">(<span class="type">int</span> k, T x, Object[] es, <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="comment">// assert n &gt; 0;</span></span><br><span class="line">    Comparable&lt;? <span class="built_in">super</span> T&gt; key = (Comparable&lt;? <span class="built_in">super</span> T&gt;) x;</span><br><span class="line">    <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> n &gt;&gt;&gt; <span class="number">1</span>;           <span class="comment">// loop while a non-leaf</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 x 沿着树重复降级直到它小于或等于其子项或者是叶子来保持堆不变性。</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) {</span><br><span class="line">        <span class="comment">// 记录两个孩子节点中的较小节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> leftChild(k); <span class="comment">// assume left child is least</span></span><br><span class="line">        <span class="comment">// 记录 两个孩子节点中的较小者</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">c</span> <span class="operator">=</span> es[child];</span><br><span class="line">        <span class="comment">// 右边孩子节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> child + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 右边孩子节点存在 并且 左边孩子节点大于右边孩子节点 寻找两个孩子节点中的较小者</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; n &amp;&amp;</span><br><span class="line">                ((Comparable&lt;? <span class="built_in">super</span> T&gt;) c).compareTo((T) es[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 更新孩子节点和索引</span></span><br><span class="line">            c = es[child = right];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key小于两个孩子节点 满足堆的性质</span></span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((T) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">        es[k] = c;</span><br><span class="line">        <span class="comment">// 下一轮开始 孩子节点比较</span></span><br><span class="line">        k = child;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 跳出循环 在位置 k 处插入项 x，</span></span><br><span class="line">    es[k] = key;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">leftChild</span><span class="params">(<span class="type">int</span> k)</span> {</span><br><span class="line">    <span class="keyword">return</span> (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这两种操作都是为了维护堆的根本性质：在最小堆中，每个父节点的值都小于或等于其子节点的值；在最大堆中，则每个父节点的值都大于或等于其子节点的值。通过 siftUp 和 siftDown，无论是在添加新元素还是在移除元素后，堆都能有效地重新调整以保持其结构和性质。</p>
<h3 id="Heapfy堆化操作"><a href="#Heapfy堆化操作" class="headerlink" title="Heapfy堆化操作"></a><strong>Heapfy</strong> 堆化操作</h3><p>将数组进行排序，使其具备二叉堆的性质。 堆化（Heapify）是一种将给定数组转换为堆结构的过程。这个操作是构建堆（特别是在进行堆排序时）的核心。堆化可以用于构建最大堆或最小堆。这里以最小堆为例来说明堆化操作的步骤：</p>
<ol>
<li><strong>理解堆的数组表示</strong>：在堆的数组表示中，对于任意位于索引 i 的节点，其左子节点位于 <code>2 * i + 1</code>，右子节点位于 <code>2 * i + 2</code>，父节点位于 <code>(i - 1) / 2</code>（假设数组索引从 0 开始）。</li>
<li><strong>找到最后一个非叶子节点</strong>：堆化过程从最后一个非叶子节点开始，向数组的起始位置遍历。在一个大小为 n 的数组中，最后一个非叶子节点的位置是 <code>(n / 2) - 1</code>。</li>
<li><strong>向下调整（Sift Down）</strong>：对于每个非叶子节点，执行向下调整的操作。这包括比较节点与其子节点的值，并在必要时交换它们的位置，以确保父节点的值大于子节点（在最大堆中）。</li>
</ol>
<ul>
<li>比较当前节点（假设索引为 i）的值与其左右子节点的值。</li>
<li>如果左子节点或右子节点的值大于当前节点的值，则将其与值最大的子节点交换。</li>
<li>继续向下调整，直至到达叶子节点或当前节点的值大于其子节点。</li>
</ul>
<p><strong>反复进行向下调整</strong>：从最后一个非叶子节点开始向上，对每个非叶子节点重复进行向下调整的过程，直到处理完数组的第一个元素。</p>
<p>通过这个过程，可以将任意数组转换成最大堆。同样的方法可以应用于构建最小堆，唯一的区别是在向下调整时确保父节点的值小于子节点的值。</p>
<p>堆化操作是构建堆和进行堆排序的关键步骤，它使得可以在 O (n) 的时间复杂度内将无序数组转换成堆结构，为高效的元素插入和删除提供了基础。</p>
<p><strong>从最后一个非叶子节点开始（int  i  = (n&gt;&gt;&gt;1) - 1 ），从后往前做 siftDown () 操作</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一个数组构建成堆</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> size;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (n &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        siftDownComparable(i, (E) es[i], es, n);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>最小堆的基础数据组成</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SOFT_MAX_ARRAY_LENGTH</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 1+2+4+8</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//用来存放数据</span></span><br><span class="line"><span class="keyword">private</span> Object[] elementData;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>最小堆的构造函数</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ComparableArrayMinHeap</span><span class="params">()</span> {</span><br><span class="line">    <span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ComparableArrayMinHeap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> {</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一个数组堆化处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data 带堆化的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ComparableArrayMinHeap</span><span class="params">(E[] data)</span> {</span><br><span class="line">    initFromArray(data);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initFromArray</span><span class="params">(E[] data)</span> {</span><br><span class="line">    initElementsFromArray(data);</span><br><span class="line">    heapify();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化堆的内存</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data 初始化传入的树组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initElementsFromArray</span><span class="params">(E[] data)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> data.length;</span><br><span class="line">    <span class="keyword">for</span> (Object e : data)</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 确保已经初始化</span></span><br><span class="line">    <span class="built_in">this</span>.elementData = ensureNonEmpty(data);</span><br><span class="line">    <span class="built_in">this</span>.size = len;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Establishes the heap</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> size;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (n &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        siftDownComparable(i, (E) es[i], es, n);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">leftChild</span><span class="params">(<span class="type">int</span> k)</span> {</span><br><span class="line">    <span class="keyword">return</span> (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rightChild</span><span class="params">(<span class="type">int</span> k)</span> {</span><br><span class="line">    <span class="keyword">return</span> (k &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">parent</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"index-0 doesn't have parent"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> (index - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>二叉堆中插入元素</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> {</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element into this priority queue.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} (as specified by {<span class="doctag">@link</span> Queue#offer})</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException   if the specified element cannot be</span></span><br><span class="line"><span class="comment"> *                              compared with elements currently in this priority queue</span></span><br><span class="line"><span class="comment"> *                              according to the priority queue's ordering</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> {</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        grow(i + <span class="number">1</span>);</span><br><span class="line">    siftUp(i, e);</span><br><span class="line">    size = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increases the capacity of the array.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">// Double size if small; else grow by 50%</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newLength(oldCapacity,</span><br><span class="line">            minCapacity - oldCapacity, <span class="comment">/* minimum growth */</span></span><br><span class="line">            oldCapacity &lt; <span class="number">64</span> ? oldCapacity + <span class="number">2</span> : oldCapacity &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="comment">/* preferred growth */</span>);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>查看二叉堆堆顶元素</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[<span class="number">0</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>取出二叉堆堆顶元素</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">final</span> Object[] es;</span><br><span class="line">    <span class="keyword">final</span> E result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((result = (E) ((es = elementData)[<span class="number">0</span>])) != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> n;</span><br><span class="line">        <span class="comment">// 数组的最后一个元素</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> (E) es[(n = --size)];</span><br><span class="line">        <span class="comment">// help gc</span></span><br><span class="line">        es[n] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 将数组的最后一位元素放入堆顶 然后执行siftDown</span></span><br><span class="line">            siftDownComparable(<span class="number">0</span>, x, es, n);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips**"></a>Tips**</h2><p>在 Java 中，<code>&gt;&gt;&gt;</code> 和 &gt;&gt; 都是位运算符，用于对整数类型的操作数执行位移操作。不过，这两个运算符在处理符号位时的行为有所不同，这是它们之间的主要区别。</p>
<h3 id="右移运算符"><a href="#右移运算符" class="headerlink" title="右移运算符 (>>)"></a><strong>右移运算符 (</strong>&gt;&gt;<strong>)</strong></h3><ul>
<li>这是一个带符号的右移运算符。</li>
<li>它将操作数向右移动指定的位数。</li>
<li>在左侧空出的位上填充原始数的最高位（符号位）。如果原始数是正数，则在左侧填充 0；如果是负数，则在左侧填充 1。</li>
<li>这意味着 &gt;&gt; 保留了操作数的符号。</li>
</ul>
<h3 id="无符号右移运算符"><a href="#无符号右移运算符" class="headerlink" title="无符号右移运算符 (>>>)"></a><strong>无符号右移运算符 (</strong>&gt;&gt;&gt;<strong>)</strong></h3><ul>
<li>这是一个无符号的右移运算符。</li>
<li>它也将操作数向右移动指定的位数。</li>
<li>不同的是，无论原始数的符号如何，在左侧空出的位上总是填充 0。</li>
<li>这意味着 &gt;&gt;&gt; 不保留操作数的符号，对于正数和负数的处理方式是一样的。</li>
</ul>
<h3 id="运算符示例"><a href="#运算符示例" class="headerlink" title="运算符示例"></a><strong>运算符示例</strong></h3><p>为了更好地理解这两个运算符的区别，让我们看一些具体的例子。假设我们有一个 8 位的整数（为了简单起见，使用 8 位而不是 Java 中的 32 位或 64 位）。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;      <span class="comment">// 二进制表示: 00000101</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> -<span class="number">5</span>;     <span class="comment">// 二进制表示: 11111011 (在8位系统中)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 &gt;&gt; 运算符</span></span><br><span class="line">System.out.println(a &gt;&gt; <span class="number">1</span>);  <span class="comment">// 结果是 2，二进制表示: 00000010</span></span><br><span class="line">System.out.println(b &gt;&gt; <span class="number">1</span>);  <span class="comment">// 结果是 -3，二进制表示: 11111101</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 &gt;&gt;&gt; 运算符</span></span><br><span class="line">System.out.println(a &gt;&gt;&gt; <span class="number">1</span>); <span class="comment">// 结果是 2，二进制表示: 00000010</span></span><br><span class="line">System.out.println(b &gt;&gt;&gt; <span class="number">1</span>); <span class="comment">// 结果是一个很大的正数</span></span><br></pre></td></tr></tbody></table></figure>

<p>在上面的例子中，对于正数 a，&gt;&gt; 和 &gt;&gt;&gt; 的结果相同。但对于负数 b，&gt;&gt; 保留了符号位，而 &gt;&gt;&gt; 通过在左侧填充 0，得到了一个很大的正数。由于 Java 使用补码表示负数，-5 的补码是 11111011，使用 &gt;&gt;&gt; 之后变成了 01111101，这是一个很大的正数。</p>
<p>总之，&gt;&gt; 是带符号的右移，它保留了数字的符号，而 &gt;&gt;&gt; 是无符号的右移，不考虑符号位。在处理负数时，这两者的差异尤为明显。</p>
<h3 id="第一个非叶子节点"><a href="#第一个非叶子节点" class="headerlink" title="第一个非叶子节点"></a>第一个非叶子节点</h3><p>为了理解 (n&gt;&gt;&gt; 1) - 1 这个表达式是如何计算出最后一个非叶子节点的，我们需要先理解堆（作为一种完全二叉树）的一些性质。</p>
<p>在一个完全二叉树中：</p>
<ul>
<li>如果树的总节点数为 n，那么叶子节点的数量大致为 n / 2（或稍微多一点，取决于 n 是奇数还是偶数）。</li>
<li>最后一个非叶子节点是第一个有叶子节点的节点，从而是最后一个叶子节点的父节点。</li>
</ul>
<p>现在来看 (n&gt;&gt;&gt; 1) - 1 这个表达式：</p>
<ul>
<li>&gt;&gt;&gt; 是 Java 中的无符号右移操作符。它将数字向右移动指定的位数。在这种情况下，n &gt;&gt;&gt; 1 相当于将 n 除以 2（向下取整），得到大约一半的节点数量。</li>
<li>因为数组索引从 0 开始，所以需要减去 1 来得到最后一个非叶子节点的正确索引。</li>
</ul>
<p>例如，假设堆有 7 个节点（索引为 0 到 6）：</p>
<ul>
<li>叶子节点是索引 3、4、5、6（总共 4 个，即 7 的一半）。</li>
<li>最后一个非叶子节点是索引 2（3 的父节点），这也是 (7&gt;&gt;&gt; 1) - 1 = 3 - 1 = 2 的结果。</li>
</ul>
<p>因此，这个表达式是一种快速而有效的方式来找到在堆（作为一个数组表示的完全二叉树）中最后一个非叶子节点的索引。</p>
<h2 id="github项目"><a href="#github项目" class="headerlink" title="github项目"></a><a href="https://github.com/nadav-cheung/algorithm">github 项目</a></h2>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>Heap</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>《排序算法纲领》</title>
    <url>/posts/d161d12f/</url>
    <content><![CDATA[<h2 id="《算法与数据结构-排序算法纲领》"><a href="#《算法与数据结构-排序算法纲领》" class="headerlink" title="《算法与数据结构:排序算法纲领》"></a>《算法与数据结构：排序算法纲领》</h2><h2 id="排序算法概览"><a href="#排序算法概览" class="headerlink" title="排序算法概览"></a>排序算法概览</h2><h3 id="排序算法的概念"><a href="#排序算法的概念" class="headerlink" title="排序算法的概念"></a><strong>排序算法的概念</strong></h3><p>排序算法是一类算法，用于将一组数据元素（通常是数组）按照特定的顺序（如升序或降序）重新排列。排序是计算机科学中基本的操作之一，广泛应用于数据处理、数据库系统、算法设计等领域。</p>
<h3 id="排序算法的本质"><a href="#排序算法的本质" class="headerlink" title="排序算法的本质"></a><strong>排序算法的本质</strong></h3><p>排序算法的本质是比较和交换（或移动）数据元素，以达到预定的顺序。这个过程通常涉及以下基本操作：</p>
<ul>
<li><strong>比较</strong>：判断两个元素之间的顺序关系。</li>
<li><strong>交换 / 移动</strong>：将元素置于正确的位置，确保它们符合排序顺序。</li>
<li><strong>迭代 / 递归</strong>：重复执行比较和交换 / 移动步骤，直到整个序列有序。</li>
</ul>
<span id="more"></span>

<h3 id="排序算法的技巧"><a href="#排序算法的技巧" class="headerlink" title="排序算法的技巧"></a><strong>排序算法的技巧</strong></h3><h3 id="选择合适的算法"><a href="#选择合适的算法" class="headerlink" title="选择合适的算法"></a>选择合适的算法</h3><ul>
<li><strong>数据大小</strong>：对于小型数组，简单的算法（如插入排序）通常足够高效。对于大型数据集，更高效的算法（如快速排序、归并排序）更为合适。</li>
<li><strong>数据结构</strong>：不同的数据结构可能更适合特定的排序算法。例如，链表排序可能更适合归并排序。</li>
<li><strong>数据特性</strong>：如果数据已部分排序，某些算法（如插入排序、冒泡排序）可能会更快。</li>
</ul>
<h3 id="稳定性考虑"><a href="#稳定性考虑" class="headerlink" title="稳定性考虑"></a>稳定性考虑</h3><ul>
<li><strong>稳定排序</strong>：保持相等元素的原始顺序。</li>
<li><strong>非稳定排序</strong>：不保证相等元素的原始顺序。</li>
</ul>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><ul>
<li><strong>原地排序</strong>：如快速排序，空间复杂度低，不需要额外的存储空间。</li>
<li><strong>非原地排序</strong>：如归并排序，需要额外的存储空间。</li>
</ul>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li><strong>最好、最坏和平均情况性能</strong>：了解不同情况下算法的时间复杂度。</li>
<li><strong>递归与非递归</strong>：递归算法（如快速排序、归并排序）与非递归算法（如堆排序）在性能上有所不同。</li>
</ul>
<h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h3><ul>
<li><strong>减少比较次数</strong>：如在快速排序中选择合适的枢轴。</li>
<li><strong>减少交换次数</strong>：如使用插入排序时进行移动而不是交换。</li>
<li><strong>混合使用排序算法</strong>：对于特定数据集，混合使用不同的排序算法可能会提高效率。</li>
</ul>
<h2 id="排序算法的起点和终点就是遍历"><a href="#排序算法的起点和终点就是遍历" class="headerlink" title="排序算法的起点和终点就是遍历"></a><strong>排序算法的起点和终点就是遍历</strong></h2><h3 id="技巧实战"><a href="#技巧实战" class="headerlink" title="技巧实战"></a><strong>技巧实战</strong></h3><p><strong>遍历数组，一维数组遍历</strong></p>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-8c942d82478f4fe5c9d126748812d7f8_1440w.png" alt="img"></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line"><span class="comment">// 遍历数组 nums[0,6) 左闭右开区间</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line"><span class="comment">// 遍历数组 nums[0,5] 左闭右闭区间</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= len - <span class="number">1</span>; i++) {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>遍历数组，寻找数组中最小的值</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;        </span><br><span class="line"><span class="comment">// 遍历数组 寻找数组中最小的元素</span></span><br><span class="line"><span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">    <span class="keyword">if</span> (nums[minIndex] &gt; nums[i]) {</span><br><span class="line">        minIndex = i;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>交换数组，交换指定位置的两个元素</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> low, <span class="type">int</span> high)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[low];</span><br><span class="line">    nums[low] = nums[high];</span><br><span class="line">    nums[high] = temp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>范型实现</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> E&gt;&gt; <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(E[] nums, <span class="type">int</span> low, <span class="type">int</span> high)</span> {</span><br><span class="line">    <span class="type">E</span> <span class="variable">temp</span> <span class="operator">=</span> nums[low];</span><br><span class="line">    nums[low] = nums[high];</span><br><span class="line">    nums[high] = temp;</span><br><span class="line">    <span class="comment">// help gc</span></span><br><span class="line">    temp = <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>一维数组扩容</strong></p>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-fa6f4b13e19bee1d785bb0f91f77d15b_1440w-20240205142454054.png" alt="一维数组扩容"></p>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-fccca21c899da599b1ea56175fc5be9d_1440w.png" alt="img"></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">// 默认增加原有素组大小的一半</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 选择 newCapacity 和 minCapacity 中的较大者</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新数组大于我们设定的最大数组长度 MAX_ARRAY_SIZE 则重新计算新数组大小</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 申请一个新的数组 数组大小为 newCapacity  并将原来数组的中数据拷贝到新数组</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Java语言实战"><a href="#Java语言实战" class="headerlink" title="Java语言实战"></a>Java 语言实战</h2><h3 id="选择排序算法"><a href="#选择排序算法" class="headerlink" title="选择排序算法"></a><a href="https://nadav.com.cn/posts/f3a42a74/">选择排序算法</a></h3><h3 id="堆排序算法"><a href="#堆排序算法" class="headerlink" title="堆排序算法"></a><a href="https://nadav.com.cn/posts/607bf52d/"><strong>堆排序算法</strong></a></h3><h3 id="插入排序算法"><a href="#插入排序算法" class="headerlink" title="插入排序算法"></a><a href="https://nadav.com.cn/posts/761b8361/">插入排序算法</a></h3><h3 id="冒泡排序算法"><a href="#冒泡排序算法" class="headerlink" title="冒泡排序算法"></a><a href="https://nadav.com.cn/posts/55c8611c/">冒泡排序算法</a></h3><h3 id="归并排序算法"><a href="#归并排序算法" class="headerlink" title="归并排序算法"></a><strong>归并排序算法</strong></h3><h3 id="快速排序算法"><a href="#快速排序算法" class="headerlink" title="快速排序算法"></a><strong>快速排序算法</strong></h3><ul>
<li><h3 id="双路快速排序算法"><a href="#双路快速排序算法" class="headerlink" title="双路快速排序算法"></a><strong>双路快速排序算法</strong></h3></li>
<li><h3 id="三路快速排序算法"><a href="#三路快速排序算法" class="headerlink" title="三路快速排序算法"></a><strong>三路快速排序算法</strong></h3></li>
</ul>
<h3 id="桶排序算法"><a href="#桶排序算法" class="headerlink" title="桶排序算法"></a><strong>桶排序算法</strong></h3><h3 id="希尔排序算法"><a href="#希尔排序算法" class="headerlink" title="希尔排序算法"></a><strong>希尔排序算法</strong></h3><h2 id="github项目"><a href="#github项目" class="headerlink" title="github项目"></a><a href="https://github.com/nadav-cheung/algorithm">github 项目</a></h2>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>排序算法纲领</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>《Tree 的基本概念》</title>
    <url>/posts/6e5a1512/</url>
    <content><![CDATA[<h2 id="《算法与数据结构-Tree的基本概念》"><a href="#《算法与数据结构-Tree的基本概念》" class="headerlink" title="《算法与数据结构:Tree的基本概念》"></a>《算法与数据结构：Tree 的基本概念》</h2><h2 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a><strong>树的基本概念</strong></h2><h3 id="树（Tree）结构简介"><a href="#树（Tree）结构简介" class="headerlink" title="树（Tree）结构简介"></a><strong>树（Tree）结构简介</strong></h3><p>树是一种层级数据结构，非常适合用来表示具有层级关系或者需要快速搜索操作的数据集合。它由节点 Nodes 组成，这些节点通过边 Edges 相连。一个树结构有以下特点：</p>
<ul>
<li><strong>树与子树：</strong>树是一个有限集合，子树则是该集合的子集。就像套娃一样，一棵树下面还包含着其子树。比如，树 T1 的子树为 树 T2、T3、T4，树 T2 的子树为 T5、T6。 上图中还有许多子树没有标记出来 。</li>
<li><strong>结点 (Node)：</strong>一个结点包括一个数据元素和若干指向其子树分支。比如，在树 T1 中，结点 A 包括一个数据元素 A 和 三个指向其子树的分支。上图中共有 18 个结点 。</li>
<li><strong>根结点 (Root)：</strong>一颗树只有一个树根，这是常识。在数据结构中，“树根” 即根节点。比如，结点 A 是树 T1 的根结点；结点 C 是树 T1 的子结点，是树 T3 的根结点。</li>
<li><strong>度 (Degree)：</strong>一个结点拥有的子树数。比如，结点 A 的度为 3，结点 G 的度为 2，结点 H 的度为 1。</li>
<li><strong>叶子 (Leaf)/ 终端结点：</strong>度为 0 的结点被称为叶子结点，很形象。比如对于树 T1 来说，结点 F、K、L、M、N、O、P、Q、R 均为叶子节点。</li>
<li><strong>分支结点 / 非终端结点：</strong>和叶子结点相对，即度不为 0 的结点。</li>
<li><strong>内部结点：</strong>顾名思义在树内部的结点，即不是根结点和叶子结点的结点。</li>
<li><strong>双亲节点或父节点：</strong>若一个节点含有子节点，则这个节点称为其子节点的父节点。如上图，A 是 B 的父节点。</li>
<li><strong>孩子节点或子节点：</strong>一个节点含有的子树的根节点称为该节点的子节点。 如上图，B 是 A 的孩子节点。</li>
<li><strong>兄弟节点：</strong>具有相同父节点的节点互称为兄弟节点。 如上图，B、C 是兄弟节点。</li>
<li><strong>堂兄弟节点：</strong>双亲在同一层的节点互为堂兄弟节点。如上图，E、F、G、H 互为堂兄弟节点。</li>
<li><strong>节点的祖先：</strong>从根到该节点所经分支上的所有节点。如上图，A 是所有节点的祖先。</li>
<li><strong>子孙：</strong>以某节点为根的子树中任一节点都称为该节点的子孙。如上图，所有节点都是 A 的子孙。</li>
<li><strong>层次 (Level)：</strong>从根结点开始，根为第一层，根的孩子为第二层，依次往下。比如，结点 K 在树 T1 中的层次为 4。</li>
<li><strong>深度 (Depth)/ 高度：</strong>指树的最大层次。比如，树 T1 的高度为 4 。</li>
<li><strong>有序树:</strong> 树中任意节点的<strong>子结点之间有顺序</strong>关系，这种树称为有序树 。</li>
<li><strong>无序树 :</strong> 树中任意节点的子结点之间没有顺序关系，这种树称为无序树，也称为<strong>自由树</strong> 。</li>
<li><strong>森林：</strong>由 m（m≥0）棵互不相交的树构成一片森林。如果把一棵非空的树的根节点删除，则该树就变成了一片森林，森林中的树由原来根节点的各棵子树构成。</li>
</ul>
<span id="more"></span>

<h3 id="树的类型"><a href="#树的类型" class="headerlink" title="树的类型"></a><strong>树的类型</strong></h3><ul>
<li><strong>二叉树（Binary Tree）</strong>：每个节点最多有两个子节点。</li>
<li><strong>二叉搜索树（Binary Search Tree, BST）</strong>：左子节点总是小于或等于父节点，右子节点总是大于或等于父节点。</li>
<li><strong>平衡二叉树（AVL Tree）</strong>：任何两个子树的高度差不超过一。</li>
<li><strong>红黑树（Red-Black Tree）</strong>：一种自平衡二叉搜索树。</li>
<li><strong>B 树和 B + 树</strong>：常用于数据库和文件系统。</li>
</ul>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-df79a03e649fa0e187e57561ada3f3b3_1440w-20240202211622577.png" alt="树概念图"></p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a><strong>二叉树</strong></h2><h3 id="二叉树的基本结构"><a href="#二叉树的基本结构" class="headerlink" title="二叉树的基本结构"></a>二叉树的基本结构</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; {</span><br><span class="line">    E key;</span><br><span class="line">    Node&lt;E&gt; left, right;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(E item)</span> {</span><br><span class="line">        key = item;</span><br><span class="line">        left = right = <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a><strong>二叉树的定义</strong></h3><ol>
<li>二叉树的前提是一棵树，满足上述对树的定义。</li>
<li>二叉树节点最多有两个子节点，分别是左子节点和右子节点</li>
</ol>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-449d5e2b246ec9f0348186e70b1368e2_1440w.png" alt="各种类型的二叉树"></p>
<h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a><strong>满二叉树</strong></h3><ol>
<li>如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树。</li>
</ol>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-6c6b28c888ee50aa172d1df533547f06_1440w-20240202211724719.png" alt="满二叉树"></p>
<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a><strong>完全二叉树</strong></h3><ol>
<li>如果二叉树中除去最后一层节点为满二叉树，且<strong>最后一层的结点依次从左到右分布</strong>，则此二叉树被称为<strong>完全二叉树</strong>。</li>
</ol>
<p><img data-src="https://pica.zhimg.com/80/v2-b67b08535e64a76f7c0ea89f55fec4b8_1440w.png?source=d16d100b" alt="完全二叉树"></p>
<h3 id="斜二叉树"><a href="#斜二叉树" class="headerlink" title="斜二叉树"></a><strong>斜二叉树</strong></h3><ol>
<li>这个很好理解，斜二叉树就是斜的二叉树，所有的节点只有左子树的称为左斜树，所有节点只有右子树的二叉树称为右斜树。</li>
</ol>
<p><img data-src="https://picx.zhimg.com/80/v2-1e25e13406d0e37ac85df39ab71ab392_1440w.png?source=d16d100b" alt="斜二叉树"></p>
<h2 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a><strong>二叉树的存储</strong></h2><ol>
<li>二叉树多采用两种方法进行存储，基于数组的顺序存储法和基于指针的二叉链式存储。</li>
</ol>
<h3 id="基于数组的顺序存储"><a href="#基于数组的顺序存储" class="headerlink" title="基于数组的顺序存储"></a>基于数组的顺序存储</h3><p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-6f75461823964caec48a9b93ff074f63_1440w.png" alt="基于数组的顺序存储"></p>
<p>左孩子节点:<br>$$<br>leftchild = parent\ast2+1<br>$$<br>右孩子节点:<br>$$<br>rightchild = parent\ast2+2<br>$$<br>父亲节点:<br>$$<br>parent = （child -1）\div 2<br>$$</p>
<h3 id="基于指针的链表存储"><a href="#基于指针的链表存储" class="headerlink" title="基于指针的链表存储"></a>基于指针的链表存储</h3><p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-d92b2516694b693c510d5b27c1f9e42f_1440w.png" alt="基于指针的链表存储"></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K, V&gt; {</span><br><span class="line">    <span class="keyword">public</span> K key;</span><br><span class="line">    <span class="keyword">public</span> V value;</span><br><span class="line">    <span class="keyword">public</span> Node&lt;K, V&gt; left, right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V value, Node&lt;K, V&gt; left, Node&lt;K, V&gt; right)</span> {</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V value)</span> {</span><br><span class="line">        <span class="built_in">this</span>(key, value, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a><strong>二叉树的遍历</strong></h2><p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-0555812e89bf1c2cd9cf07dc8b2f5d0a_1440w-20240202211958386.png" alt="二叉树遍历的本质"></p>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-3e4b6a0b3014de2db8aec536ba15cd83_1440w.png" alt="img"></p>
<h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><ol>
<li>前序遍历的顺序是，对于树中的某节点，先遍历该节点，然后再遍历其左子树，最后遍历其右子树。</li>
</ol>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-32f29fd1ed5bf2398946530744c4b3bf_1440w.png" alt="img"></p>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><ol>
<li>中序遍历的顺序是，对于树中的某节点，先遍历该节点的左子树，然后再遍历该节点，最后遍历其右子树。</li>
</ol>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-910eec6d46dc458e3dc99f3914e214fe_1440w.png" alt="img"></p>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><ol>
<li>后序遍历的顺序是，对于树中的某节点，先遍历该节点的左子树，再遍历其右子树，最后遍历该节点。</li>
</ol>
<p><img data-src="https://pic1.zhimg.com/80/v2-2b3cfa0c82015e56ebc717a3911f2462_1440w.png?source=d16d100b" alt="img"></p>
<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><ol>
<li>顾名思义，一层一层的遍历。</li>
</ol>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-c2eae211e5f3e55721b28a31ccfa91cb_1440w.png" alt="img"></p>
<h2 id="遍历衍生算法"><a href="#遍历衍生算法" class="headerlink" title="遍历衍生算法"></a>遍历衍生算法</h2><ol>
<li>归并排序  后续遍历   </li>
<li>快速排序   前序遍历 </li>
</ol>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-c8e7df0d473656b8f82f7ac46c02461c_1440w.png" alt="img"></p>
<h2 id="github项目"><a href="#github项目" class="headerlink" title="github项目"></a><a href="https://github.com/nadav-cheung/algorithm">github 项目</a></h2>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>《Java 开发者的探索之旅》</title>
    <url>/posts/1887ef/</url>
    <content><![CDATA[<h2 id="《算法与数据结构-Java开发者的探索之旅》专栏简介"><a href="#《算法与数据结构-Java开发者的探索之旅》专栏简介" class="headerlink" title="《算法与数据结构:Java开发者的探索之旅》专栏简介"></a>《算法与数据结构：Java 开发者的探索之旅》专栏简介</h2><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>欢迎来到《算法与数据结构：Java 开发者的探索之旅》一个专为 Java 程序员设计的综合学习平台。无论您是初涉编程世界的新手，还是经验丰富的行业专家，这里都有您需要的知识和资源。通过本专栏，我们将共同探索算法的奥秘和数据结构的精髓，不仅提升您的编程技能，还将激发您解决复杂问题的能力。</p>
<h2 id="第一部分：基础篇"><a href="#第一部分：基础篇" class="headerlink" title="第一部分：基础篇"></a>第一部分：基础篇</h2><h3 id="1-算法和数据结构入门"><a href="#1-算法和数据结构入门" class="headerlink" title="1. 算法和数据结构入门"></a>1. 算法和数据结构入门</h3><p>对于刚开始学习 Java 的读者，我们将从最基本的算法和数据结构开始。这包括了解数组、链表、栈、队列、堆、字典、集合、树等基础数据结构，以及排序和搜索等基本算法。</p>
<span id="more"></span>

<h3 id="2-Java标准库实现"><a href="#2-Java标准库实现" class="headerlink" title="2. Java标准库实现"></a>2. Java 标准库实现</h3><p>我们将深入探讨如何在 Java 中有效实现和使用这些基础算法和数据结构，包括 Java 标准库的利用和一些最佳实践。同时带领大家研读 Java17 中，标准库是如何实现这个算法与数据结构的。</p>
<h3 id="3-LeetCode简单题实战"><a href="#3-LeetCode简单题实战" class="headerlink" title="3. LeetCode简单题实战"></a>3. LeetCode 简单题实战</h3><p>对于每一种算法和数据结构，还会挑选 LeetCode 经典题型进行实战，授之以鱼，授之以渔。</p>
<h2 id="第二部分：进阶篇"><a href="#第二部分：进阶篇" class="headerlink" title="第二部分：进阶篇"></a>第二部分：进阶篇</h2><h3 id="4-高级数据结构"><a href="#4-高级数据结构" class="headerlink" title="4. 高级数据结构"></a>4. 高级数据结构</h3><p>为了满足更有经验的读者，我们将探讨树、图、堆等更高级的数据结构，以及它们在复杂应用中的使用，同时带领大家手写各种高级数据结构，以求对细节了然于胸。</p>
<h3 id="5-复杂算法探索"><a href="#5-复杂算法探索" class="headerlink" title="5. 复杂算法探索"></a>5. 复杂算法探索</h3><p>深入了解诸如动态规划、贪心算法、图算法等高级算法，并探讨它们在 LeetCode 中解题的应用。</p>
<h2 id="第三部分：专业篇"><a href="#第三部分：专业篇" class="headerlink" title="第三部分：专业篇"></a>第三部分：专业篇</h2><h3 id="6-性能优化与分析"><a href="#6-性能优化与分析" class="headerlink" title="6. 性能优化与分析"></a>6. 性能优化与分析</h3><p>这部分专为那些希望提升其 Java 应用性能的专业人士准备。我们将讨论如何评估算法效率，并提供优化技巧。</p>
<h3 id="7-实战案例与新趋势"><a href="#7-实战案例与新趋势" class="headerlink" title="7. 实战案例与新趋势"></a>7. 实战案例与新趋势</h3><p>结合真实世界的案例，我们将展示高级算法和数据结构在解决实际问题时的强大力量。此外，还将关注行业的最新趋势和未来的发展方向。</p>
<h2 id="第四部分：无招胜有招"><a href="#第四部分：无招胜有招" class="headerlink" title="第四部分：无招胜有招"></a>第四部分：无招胜有招</h2><h3 id="8-LeetCode实战"><a href="#8-LeetCode实战" class="headerlink" title="8. LeetCode实战"></a>8. LeetCode 实战</h3><p>通过对算法和数据结构中各种数据结构的阐释，帮助大家培养计算机思维模式，最后以击穿 LeetCode 三百道经典题型作为本专题的出师条件。</p>
<h2 id="适宜读者"><a href="#适宜读者" class="headerlink" title="适宜读者"></a><strong>适宜读者</strong></h2><p>无论你是 Java 新手，还是有着丰富开发经验的专业人士，这个专栏都将为你提供宝贵的学习资源和启发。加入我们，一起在算法与数据结构的世界中不断成长！</p>
<h2 id="github项目"><a href="#github项目" class="headerlink" title="github项目"></a><a href="https://github.com/nadav-cheung/algorithm">github 项目</a></h2>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>Java开发者的探索之旅</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>写作</tag>
      </tags>
  </entry>
  <entry>
    <title>《插入排序算法》</title>
    <url>/posts/761b8361/</url>
    <content><![CDATA[<h2 id="《算法与数据结构-插入排序算法》"><a href="#《算法与数据结构-插入排序算法》" class="headerlink" title="《算法与数据结构:插入排序算法》"></a>《算法与数据结构：插入排序算法》</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>插入排序是一种简单直观的排序算法，它通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实践中对小型数组表现良好，尤其是当数组部分已经排序时。</p>
<p><strong>算法思想</strong></p>
<p>插入排序的基本思想是将待排序的元素看作一个有序表和一个无序表。开始时，有序表中只包含一个元素，而无序表中包含有 n-1 个元素。在排序过程中，每次从无序表中取出第一个元素，将其与有序表中的元素的排序码进行比较，然后将其插入到有序表中的适当位置，形成新的有序表。</p>
<h3 id="关键特点"><a href="#关键特点" class="headerlink" title="关键特点"></a>关键特点</h3><ul>
<li><strong>简单直观</strong>：易于理解和实现。</li>
<li><strong>适用于小型数组</strong>：对于小数据量效率高。</li>
<li><strong>稳定排序</strong>：相等元素的顺序不会改变。</li>
</ul>
<h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a><strong>算法原理</strong></h3><ol>
<li><strong>开始排序</strong>：从数组的第二个元素开始，这是因为单个元素默认已排序。</li>
<li><strong>选择元素</strong>：选择当前元素，与前面的元素进行比较。</li>
<li><strong>寻找位置</strong>：如果当前元素小于它前面的元素，则将前面的元素向后移动。</li>
<li><strong>插入元素</strong>：重复步骤 3 直到找到当前元素的正确位置，然后将它插入。</li>
<li><strong>重复过程</strong>：对数组中的每个未排序元素重复步骤 2-4。</li>
<li><strong>完成排序</strong>：当所有元素都被考虑过，数组排序完成。</li>
</ol>
<span id="more"></span>

<p>为了更清楚地演示插入排序算法的过程，我们可以使用一个表格来详细展示每一步的操作。假设我们有一个初始数组 [5, 3, 4, 1, 2]，下面是用插入排序对这个数组进行排序的逐步过程：</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>当前数组状态</th>
<th>当前元素</th>
<th>已排序部分</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td> 1</td>
<td>[5, 3, 4, 1, 2]</td>
<td>3</td>
<td>[5]</td>
<td> 将 3 插入到 5 前面</td>
</tr>
<tr>
<td> 2</td>
<td>[3, 5, 4, 1, 2]</td>
<td>4</td>
<td>[3, 5]</td>
<td> 将 4 插入到 5 前面</td>
</tr>
<tr>
<td> 3</td>
<td>[3, 4, 5, 1, 2]</td>
<td>1</td>
<td>[3, 4, 5]</td>
<td> 将 1 插入到 3 前面</td>
</tr>
<tr>
<td> 4</td>
<td>[1, 3, 4, 5, 2]</td>
<td>2</td>
<td>[1, 3, 4, 5]</td>
<td> 将 2 插入到 3 前面</td>
</tr>
<tr>
<td> 5</td>
<td>[1, 2, 3, 4, 5]</td>
<td>-</td>
<td>[1, 2, 3, 4, 5]</td>
<td> 所有元素已排序，算法完成</td>
</tr>
</tbody></table>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a><strong>算法步骤</strong></h3><ul>
<li><strong>步骤 1</strong>：从数组的第二个元素（3）开始，将其与前面的元素（5）比较，由于 3 小于 5，因此将 3 插入到 5 的前面。</li>
<li><strong>步骤 2</strong>：接着处理下一个元素（4），将其与前面已排序部分（3 和 5）进行比较，4 应该插入到 5 前面。</li>
<li><strong>步骤 3</strong>：处理元素 1，它比前面的所有元素都小，所以将它移动到数组的最前面。</li>
<li><strong>步骤 4</strong>：处理元素 2，它应该被插入到 1 和 3 之间。</li>
<li><strong>步骤 5</strong>：此时，所有元素已经排序完成。</li>
</ul>
<p>每一步中，“当前元素” 是指正在处理的数组元素，“已排序部分” 是指该元素之前的数组部分，它在每一步结束时都已经排好序。</p>
<p>通过这个逐步的表格演示，您可以清楚地看到插入排序算法是如何一步一步地将数组排序的。这种算法特别适合于数组已部分排序的情况，因为这样可以减少比较和移动次数，从而提高效率。</p>
<h3 id="图画演示"><a href="#图画演示" class="headerlink" title="图画演示"></a><strong>图画演示</strong></h3><p>创建一个演示数组【3，5，1，2，4】，数组长度为 5，数组表示为 nums [0,5) 左闭右开区间。</p>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-2dac7c3cfd114de165ca6d007ce5de83_1440w-20240205145358699.png" alt="图2 选择元素5，插入已经排序数组中的合适位置"></p>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-4d25fc8d6299b09c86381f07cce39b1e_1440w.png" alt="图3 选择元素1，插入已经排序数组中的合适位置"></p>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-ac8866576e8e9a7e1623bd5067429c2e_1440w-20240205145557782.png" alt="图7 选择元素4，插入已经排序数组中的合适位置"></p>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-30e8ed7a08a016ef70939b69b153e6cd_1440w.png" alt="图8 排序完成"></p>
<h3 id="动画GIF演示"><a href="#动画GIF演示" class="headerlink" title="动画GIF演示"></a><strong>动画 GIF 演示</strong></h3><p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-b553e1fc957d33fc92682ab8096f1372_1440w.gif" alt="动画GIF演示"></p>
<h3 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a><strong>Java 代码实现</strong></h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertionSort</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">InsertionSort</span><span class="params">()</span> {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 宏观前提  数组左闭右开</span></span><br><span class="line"><span class="comment">     * i 表示已经排序待数组的长度</span></span><br><span class="line"><span class="comment">     * nums[0,i)已经排序</span></span><br><span class="line"><span class="comment">     * nums[i,n)未排序</span></span><br><span class="line"><span class="comment">     * 每轮排序选择未排序中的第一个元素插入到已经排序的数组的合适位置中，使之成为新的已排序数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 待排序待数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 当一个数组中只有一个元素，那么这个数组天然就是已经排序的数组</span></span><br><span class="line">        <span class="comment">// nums[0，1）是已经排序的数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) {</span><br><span class="line">            <span class="comment">// 未排序列表中的第一个元素，待排序元素</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> nums[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将待排序元素插入已经排序的数组nums[0,i)中</span></span><br><span class="line">            <span class="comment">// 使数组nums[0,i+1)成为新的已经排序数组</span></span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = i; j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; ret &lt; nums[j - <span class="number">1</span>]; j--) {</span><br><span class="line">                nums[j] = nums[j - <span class="number">1</span>];</span><br><span class="line">            }</span><br><span class="line">            nums[j] = ret;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong>Java 范型接口</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> E&gt;&gt; <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(E[] nums)</span> {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) {</span><br><span class="line">        <span class="comment">// 待排序代元素</span></span><br><span class="line">        <span class="type">E</span> <span class="variable">ret</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = i; j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; ret.compareTo(nums[j - <span class="number">1</span>]) &lt; <span class="number">0</span>; j--) {</span><br><span class="line">            nums[j] = nums[j - <span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">        nums[j] = ret;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="github项目"><a href="#github项目" class="headerlink" title="github项目"></a><a href="https://github.com/nadav-cheung/algorithm">github 项目</a></h2>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>插入排序算法</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>排序算法</tag>
        <tag>插入排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>《冒泡排序算法》</title>
    <url>/posts/55c8611c/</url>
    <content><![CDATA[<h2 id="《算法与数据结构-冒泡排序算法》"><a href="#《算法与数据结构-冒泡排序算法》" class="headerlink" title="《算法与数据结构:冒泡排序算法》"></a>《算法与数据结构：冒泡排序算法》</h2><h2 id="冒泡排序算法"><a href="#冒泡排序算法" class="headerlink" title="冒泡排序算法"></a>冒泡排序算法</h2><h3 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a><strong>算法简介</strong></h3><p>冒泡排序是一种简单的排序算法，它重复地遍历待排序的元素列表，比较相邻的元素，并在需要时交换它们的位置。每遍历一次列表，至少有一个元素会被移至其正确的位置，这个过程类似于气泡从水底升到水面的过程，因此得名 “冒泡排序”。</p>
<h3 id="关键特点"><a href="#关键特点" class="headerlink" title="关键特点"></a><strong>关键特点</strong></h3><ul>
<li><strong>简单直观</strong>：易于理解和实现。</li>
<li><strong>效率较低</strong>：对于大量元素的列表，其性能不如更复杂的排序算法。</li>
<li><strong>稳定性</strong>：相等的元素在排序后保持原有顺序。</li>
</ul>
<h3 id="算法工作原理"><a href="#算法工作原理" class="headerlink" title="算法工作原理"></a>算法工作原理</h3><ul>
<li><strong>比较和交换</strong>：从列表的开始处开始，比较相邻的两个元素，如果它们的顺序错误就把它们交换过来。</li>
<li><strong>重复过程</strong>：对列表的每一对相邻元素执行步骤 1，直到列表的末尾。这完成了列表的一次完整遍历。</li>
<li><strong>重复遍历</strong>：重复步骤 1 和 2，每次遍历都会减少最后一个比较的元素。</li>
<li><strong>完成排序</strong>：当没有更多元素需要比较时，列表排序完成。</li>
</ul>
<span id="more"></span>

<h3 id="表格演示"><a href="#表格演示" class="headerlink" title="表格演示"></a>表格演示</h3><p>为了展示冒泡排序算法的步骤，我会使用一个简单的例子，并通过表格的形式来展示每一步的操作。假设我们有一个数列 [5, 3, 8, 4, 2]，我们将按照冒泡排序的规则对其进行排序。以下是排序的详细步骤：</p>
<p><strong>初始数列</strong>: | 5 | 3 | 8 | 4 | 2 |</p>
<p><strong>第一轮比较</strong>:</p>
<ul>
<li>比较 5 和 3，交换位置，因为 5 &gt; 3 </li>
<li>比较 5 和 8，不交换，因为 5&lt; 8 </li>
<li>比较 8 和 4，交换位置，因为 8 &gt; 4 </li>
<li>比较 8 和 2，交换位置，因为 8&gt;2</li>
</ul>
<p>| 3 | 5 | 4 | 2 | 8 |</p>
<p><strong>第二轮比较</strong>:</p>
<ul>
<li>比较 3 和 5，不交换，因为 3&lt; 5 </li>
<li>比较 5 和 4，交换位置，因为 5&gt;4 </li>
<li>比较 5 和 2，交换位置，因为 5&gt; 2 </li>
<li>此轮不再与 8 比较，因为 8 已经是最大的了</li>
</ul>
<p>| 3 | 4 | 2 | 5 | 8 |</p>
<p><strong>第三轮比较</strong>:</p>
<ul>
<li>比较 3 和 4，不交换，因为 3&lt; 4 </li>
<li>比较 4 和 2，交换位置，因为 4 &gt; 2 </li>
<li>此轮不再与 5 和 8 比较</li>
</ul>
<p>| 3 | 2 | 4 | 5 | 8 |</p>
<p><strong>第四轮比较</strong>:</p>
<ul>
<li>比较 3 和 2，交换位置，因为 3 &gt; 2 </li>
<li>此轮不再与 4，5 和 8 比较</li>
</ul>
<p>| 2 | 3 | 4 | 5 | 8 |</p>
<p><strong>结束</strong>:</p>
<ul>
<li>所有元素均已正确排序</li>
</ul>
<h3 id="图画演示"><a href="#图画演示" class="headerlink" title="图画演示"></a><strong>图画演示</strong></h3><p>创建一个演示数组【3，5，1，2，4】，数组长度为 5，数组表示为 <code>nums[0,5)</code> 左闭右开区间。</p>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-d32eb92f1471f29cc8a80e40902e8a2f_1440w.png" alt="img"></p>
<h3 id="动画GIF演示"><a href="#动画GIF演示" class="headerlink" title="动画GIF演示"></a><strong>动画 GIF 演示</strong></h3><p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-700e50020997cb4fdb870d2b79ba807f_1440w.gif" alt="冒泡排序算法GIF"></p>
<h3 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a><strong>Java 代码实现</strong></h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 宏观前提  数组左闭右开</span></span><br><span class="line"><span class="comment">     * i 表示进行的第i轮排序</span></span><br><span class="line"><span class="comment">     * nums[0,n-i)未排序</span></span><br><span class="line"><span class="comment">     * nums[n-1,n)已经排序</span></span><br><span class="line"><span class="comment">     * 每轮排序选择未排序中最大的元素放在nums[n-i-1]位置</span></span><br><span class="line"><span class="comment">     * 每轮排序结束  nums[n-i-1]位置 元素确认</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 待排序数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 每轮排序都将能确定至少一个元素的位置，</span></span><br><span class="line">        <span class="comment">// 共有n个元素，当n-1个元素的位置已经确定，</span></span><br><span class="line">        <span class="comment">// 剩下的一个元素位置必将确认</span></span><br><span class="line">        <span class="comment">// 所以只需要进行n-1轮排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="comment">// 针对每一轮排序 我们只做一件事</span></span><br><span class="line">            <span class="comment">// 1、在nums[n-i-1]的位置上放上正确的数据</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++) {</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) {</span><br><span class="line">                    swap(nums, j, j + <span class="number">1</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> low, <span class="type">int</span> high)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[low];</span><br><span class="line">        nums[low] = nums[high];</span><br><span class="line">        nums[high] = temp;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Java范型实现"><a href="#Java范型实现" class="headerlink" title="Java范型实现"></a>Java 范型实现</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> E&gt;&gt; <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(E[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++) {</span><br><span class="line">                <span class="keyword">if</span> (nums[j].compareTo(nums[j + <span class="number">1</span>]) &gt; <span class="number">0</span>) {</span><br><span class="line">                    swap(nums, j, j + <span class="number">1</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> E&gt;&gt; <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(E[] nums, <span class="type">int</span> low, <span class="type">int</span> high)</span> {</span><br><span class="line">        <span class="type">E</span> <span class="variable">temp</span> <span class="operator">=</span> nums[low];</span><br><span class="line">        nums[low] = nums[high];</span><br><span class="line">        nums[high] = temp;</span><br><span class="line">        <span class="comment">// help gc</span></span><br><span class="line">        temp = <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="github项目"><a href="#github项目" class="headerlink" title="github项目"></a><a href="https://github.com/nadav-cheung/algorithm">github 项目</a></h2>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>冒泡排序算法</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>冒泡排序算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>《选择排序算法》</title>
    <url>/posts/f3a42a74/</url>
    <content><![CDATA[<h2 id="《算法与数据结构-选择排序算法》"><a href="#《算法与数据结构-选择排序算法》" class="headerlink" title="《算法与数据结构:选择排序算法》"></a>《算法与数据结构：选择排序算法》</h2><h2 id="选择排序算法"><a href="#选择排序算法" class="headerlink" title="选择排序算法"></a>选择排序算法</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>选择排序是一种简单直观的排序算法。它的工作原理是每次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。选择排序是不稳定的排序方法（即相同的元素可能在排序后的序列中有不同的顺序）。</p>
<h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a><strong>算法原理</strong></h3><p>选择排序算法的主要步骤如下：</p>
<ol>
<li>在未排序序列中找到最小（或最大）元素，存放到排序序列的起始位置。</li>
<li>从剩余未排序元素中继续寻找最小（或最大）元素，然后放到已排序序列的末尾。</li>
<li>重复第二步，直到所有元素均排序完毕。</li>
</ol>
<span id="more"></span>

<h3 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a><strong>算法演示</strong></h3><p>假设有一个未排序的数组：[5, 3, 6, 2, 10]</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>当前数组状态</th>
<th>选中元素</th>
</tr>
</thead>
<tbody><tr>
<td> 1</td>
<td>5, 3, 6, 2, 10</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>2, 3, 6, 5, 10</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>2, 3, 6, 5, 10</td>
<td>5</td>
</tr>
<tr>
<td>4</td>
<td>2, 3, 5, 6, 10</td>
<td>6</td>
</tr>
<tr>
<td>5</td>
<td>2, 3, 5, 6, 10</td>
<td>10</td>
</tr>
</tbody></table>
<h3 id="图画演示"><a href="#图画演示" class="headerlink" title="图画演示"></a><strong>图画演示</strong></h3><p>创建一个演示数组【3，5，1，2，4】，数组长度为 5，数组表示为 nums [0,5) 左闭右开区间。</p>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-4af66934d195afaf592638d8459ae849_1440w.png" alt="图1 选择最小元素1 与未排序队列的第一个元素交换"></p>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-7ad51a4ac0069fc97ac9207121137820_1440w-20240205141627224.png" alt="图2 从剩余未排序队列中寻找最小值与未排序队列中第一元素交换"></p>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-11292aa62f8f05995ecb0c648e0cf873_1440w-20240205141652766.png" alt="img"></p>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-384335894903c5a3e1b3d253673d2c5e_1440w-20240205141716171.png" alt="img"></p>
<h3 id="动画GIF演示"><a href="#动画GIF演示" class="headerlink" title="动画GIF演示"></a><strong>动画 GIF 演示</strong></h3><p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-899dc68dae19d22dec4510faa03f1650_1440w-20240205141738874.gif" alt="选择排序算法GIF动画"></p>
<h3 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a><strong>Java 代码实现</strong></h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectionSort</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 宏观前提  数组左闭右开</span></span><br><span class="line"><span class="comment">     * i 表示进行的第i轮排序</span></span><br><span class="line"><span class="comment">     * nums[0,i)已经排序</span></span><br><span class="line"><span class="comment">     * nums[i,n)未排序</span></span><br><span class="line"><span class="comment">     * 每轮排序从未排序的列表中选择最小的元素，放在未排序的列表起始位置i上</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 待排序数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">            <span class="comment">// 记录未排序列表中最小元素下标</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; len; j++) {</span><br><span class="line">                <span class="keyword">if</span> (nums[minIndex] &gt; nums[j]) {</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            swap(nums, i, minIndex);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> low, <span class="type">int</span> high)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[low];</span><br><span class="line">        nums[low] = nums[high];</span><br><span class="line">        nums[high] = temp;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Java范型实现"><a href="#Java范型实现" class="headerlink" title="Java范型实现"></a>Java 范型实现</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectionSort</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> E&gt;&gt; <span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(E[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; len; j++) {</span><br><span class="line">                <span class="keyword">if</span> (nums[minIndex].compareTo(nums[j]) &gt; <span class="number">0</span>) {</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            swap(nums, minIndex, i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> E&gt;&gt; <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(E[] nums, <span class="type">int</span> low, <span class="type">int</span> high)</span> {</span><br><span class="line">        <span class="type">E</span> <span class="variable">temp</span> <span class="operator">=</span> nums[low];</span><br><span class="line">        nums[low] = nums[high];</span><br><span class="line">        nums[high] = temp;</span><br><span class="line">        <span class="comment">// help gc</span></span><br><span class="line">        temp = <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="github项目"><a href="#github项目" class="headerlink" title="github项目"></a><a href="https://github.com/nadav-cheung/algorithm">github 项目</a></h2>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>选择排序算法</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>排序算法</tag>
        <tag>选择排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>《Node》</title>
    <url>/posts/fc608e54/</url>
    <content><![CDATA[<h2 id="《算法与数据结构-Node》"><a href="#《算法与数据结构-Node》" class="headerlink" title="《算法与数据结构:Node》"></a>《算法与数据结构：Node》</h2><h2 id="节点（Node）数据结构基石"><a href="#节点（Node）数据结构基石" class="headerlink" title="节点（Node）数据结构基石"></a>节点（Node）数据结构基石</h2><h3 id="理解Node数据结构及其应用"><a href="#理解Node数据结构及其应用" class="headerlink" title="理解Node数据结构及其应用"></a><strong>理解 Node 数据结构及其应用</strong></h3><p>Node（节点）在计算机科学中扮演着核心角色，它是构建更复杂数据结构的基石。深入理解 Node 及其在各种数据结构中的应用，对于开发高效、可扩展的软件应用至关重要。</p>
<h3 id="Node节点概念"><a href="#Node节点概念" class="headerlink" title="Node节点概念"></a>Node 节点概念</h3><ul>
<li><strong>定义与结构</strong>：Node 通常是一个包含数据和指向其他节点的引用的对象。它的结构可能因应用的不同而有所不同，但通常包括至少一个数据字段和一个或多个链接字段。</li>
<li><strong>类型</strong>：<ul>
<li><strong>单链表节点</strong>：包含数据和指向下一个节点的单个链接。</li>
<li><strong>双链表节点</strong>：除了指向下一个节点的链接外，还有指向前一个节点的链接。</li>
<li><strong>树节点</strong>：包含多个链接，通常指向其子节点。</li>
<li><strong>图节点</strong>：可以有多个链接，指向多个其他节点，表示图中的边。</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h3 id="Node在数据结构中的应用"><a href="#Node在数据结构中的应用" class="headerlink" title="Node在数据结构中的应用"></a>Node 在数据结构中的应用</h3><ol>
<li><strong>链表（Linked Lists）</strong>：在链表中，每个节点包含数据和指向下一个节点的引用。链表可以是单向的（每个节点只有一个指向下一个节点的链接）或双向的（每个节点有两个链接，分别指向前一个节点和下一个节点）。链表的优势在于它可以高效地在任何位置添加或删除节点。</li>
<li><strong>树（Trees）</strong>：在树形结构中，每个节点包含数据和几个指向子节点的链接。树的一个常见例子是二叉树，其中每个节点最多有两个子节点。树被广泛用于表示具有层次结构的数据，例如文件系统。</li>
<li><strong>图（Graphs）</strong>：图是由节点（在图中称为顶点）和边组成的数据结构。每个边连接两个节点。图可以用来表示网络，如社交网络或交通网络。</li>
<li><strong>堆（Heaps）</strong>：堆是一种特殊的树形结构，用于实现优先队列。在堆中，节点的排列方式依赖于它们的键值，以保证对堆顶（根节点）的快速访问。</li>
<li><strong>散列表（Hash Tables）</strong>：虽然散列表通常不直接展示其节点，但它们内部使用节点来存储键值对。散列函数决定了键应该存储在哪个节点中。</li>
</ol>
<ul>
<li><strong>链表</strong><ul>
<li><strong>类型</strong>：<ul>
<li>单向链表</li>
<li>双向链表</li>
<li>循环链表</li>
</ul>
</li>
<li><strong>操作</strong>：<ul>
<li>插入：在链表的特定位置插入新节点。</li>
<li>删除：移除特定节点。</li>
<li>搜索：查找具有特定值的节点。</li>
<li><strong>应用</strong>：栈、队列的实现，动态内存分配。</li>
</ul>
</li>
</ul>
</li>
<li><strong>树</strong><ul>
<li><strong>类型</strong>：<ul>
<li>二叉树</li>
<li>平衡树（如 AVL 树）</li>
<li>B 树及其变种</li>
</ul>
</li>
<li><strong>操作</strong>：<ul>
<li>插入：在树中加入新节点。</li>
<li>删除：移除树中的节点。</li>
<li>遍历：按顺序访问树中的每个节点（前序、中序、后序）。</li>
<li><strong>应用</strong>：数据库索引，文件系统。</li>
</ul>
</li>
</ul>
</li>
<li><strong>图</strong><ul>
<li><strong>类型</strong>：<ul>
<li>有向图</li>
<li>无向图</li>
</ul>
</li>
<li><strong>操作</strong>：<ul>
<li>添加边：连接两个节点。</li>
<li>删除边：移除两个节点间的连接。</li>
<li>遍历：例如深度优先搜索（DFS）或广度优先搜索（BFS）。</li>
<li><strong>应用</strong>：社交网络分析，路由算法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Node的Java版本实现"><a href="#Node的Java版本实现" class="headerlink" title="Node的Java版本实现"></a>Node 的 Java 版本实现</h3><p><strong>详细实现示例</strong>：</p>
<p>​	<strong>链表节点实现</strong>：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>&lt;E&gt; {</span><br><span class="line">    E data;</span><br><span class="line">    ListNode&lt;E&gt; next;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(E data)</span> {</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>​	<strong>二叉树节点实现</strong>：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;E&gt; {</span><br><span class="line">    E data;</span><br><span class="line">    TreeNode&lt;E&gt; left;</span><br><span class="line">    TreeNode&lt;E&gt; right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(E data)</span> {</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>​	<strong>图节点实现</strong>：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GraphNode</span>&lt;E&gt; {</span><br><span class="line">    E data;</span><br><span class="line">    List&lt;GraphNode&lt;E&gt;&gt; neighbors;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GraphNode</span><span class="params">(E data)</span> {</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.neighbors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Node的重要性和高级应用"><a href="#Node的重要性和高级应用" class="headerlink" title="Node的重要性和高级应用"></a>Node 的重要性和高级应用</h3><ul>
<li><strong>高级算法中的应用</strong>：</li>
<li><strong>排序算法</strong>：例如归并排序在链表上的应用。</li>
<li><strong>动态编程问题</strong>：使用树结构存储中间结果。</li>
<li><strong>网络算法</strong>：使用图结构模拟和解决网络路由和连接问题。</li>
<li><strong>性能考量</strong>：</li>
<li><strong>时间复杂度</strong>：不同结构的节点操作具有不同的时间复杂度，如链表的插入操作通常是 O (1)，而数组则是 O (n)。</li>
<li><strong>空间复杂度</strong>：节点结构对内存的使用效率也有重要影响。</li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="单向链表图解"><a href="#单向链表图解" class="headerlink" title="单向链表图解"></a><strong>单向链表图解</strong></h3><p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-9d6f3626b03a40adcd8a53078fb9b437_1440w-20240205103943136.png" alt="Node表示图"></p>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-4039b5a46049f1e424af059786bfb655_1440w.png" alt="单链表"></p>
<h3 id="单向链表遍历"><a href="#单向链表遍历" class="headerlink" title="单向链表遍历"></a><strong>单向链表遍历</strong></h3><p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-3a1ea3f280fade135dcf3df14e6e26a3_1440w.png" alt="单向链表遍历"></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">链表遍历</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>{</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">}</span><br><span class="line">  </span><br><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(ListNode head)</span> {</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head; p!=<span class="literal">null</span>; p = p.next){</span><br><span class="line">      <span class="comment">// p.val</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">  </span><br><span class="line"><span class="comment">//递归 </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(ListNode head)</span>{</span><br><span class="line">     <span class="comment">// 递归 head.val;</span></span><br><span class="line">     traverse(head.next);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="单向链表遍历实战"><a href="#单向链表遍历实战" class="headerlink" title="单向链表遍历实战"></a>单向链表遍历实战</h3><p>todo queue 队列的实现</p>
<h3 id="单向链表插入"><a href="#单向链表插入" class="headerlink" title="单向链表插入"></a>单向<strong>链表插入</strong></h3><p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-2dbbaef6f4d1299d6259f2a9f913a101_1440w.png" alt="img"></p>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-f5fd7553216e196ab007993af38099b9_1440w-20240205104104861.png" alt="单链表插入"></p>
<h3 id="单向链表更新"><a href="#单向链表更新" class="headerlink" title="单向链表更新"></a><strong>单向链表更新</strong></h3><p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-65245e14b57d200338e2e1a0cf1ef3e4_1440w.png" alt="单向链表更新"></p>
<h3 id="单向链表删除"><a href="#单向链表删除" class="headerlink" title="单向链表删除"></a><strong>单向链表删除</strong></h3><p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-6db78fef5c6a1a67e77e31ce3362a89f_1440w.png" alt="单向链表删除"></p>
<h3 id="双向链表图解"><a href="#双向链表图解" class="headerlink" title="双向链表图解"></a><strong>双向链表图解</strong></h3><p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-25bc61e297e048dfdb2b578522189a07_1440w-20240205104210736.png" alt="双向链表"></p>
<h3 id="双向链表新增元素"><a href="#双向链表新增元素" class="headerlink" title="双向链表新增元素"></a><strong>双向链表新增元素</strong></h3><p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-b4a8c63294ae5d6b8a5c6c47ee1fda40_1440w.png" alt="双向链表插插入元素"></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 双向链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; {</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts element e before non-null Node succ.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> {</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a><strong>字典树</strong></h2><h2 id="BST树"><a href="#BST树" class="headerlink" title="BST树"></a><strong>BST 树</strong></h2><p>todo</p>
<h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a><strong>AVL 树</strong></h2><p>todo</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a><strong>红黑树</strong></h2><h2 id="github项目"><a href="#github项目" class="headerlink" title="github项目"></a><a href="https://github.com/nadav-cheung/algorithm">github 项目</a></h2>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>Node</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>节点</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>《手写 ArrayList》</title>
    <url>/posts/e7bb25a0/</url>
    <content><![CDATA[<h2 id="《算法与数据结构-手写ArrayList》"><a href="#《算法与数据结构-手写ArrayList》" class="headerlink" title="《算法与数据结构:手写ArrayList》"></a>《算法与数据结构：手写 ArrayList》</h2><h3 id="List的数组"><a href="#List的数组" class="headerlink" title="List的数组"></a>List 的数组</h3><p>List（列表）是编程中一种极为常见且重要的数据结构，用于存储元素的有序集合。在 Java 中，List 是一个接口，它允许我们以线性方式存储元素，同时提供了一系列操作这些元素的方法，List 是线性表的一种。</p>
<p>线性表是一种最基本、最简单、也是最常用的一种数据结构。一个线性表是 n 个具有相同特性的数据元素的有限序列。在这些元素中，每个元素都有一个前驱和一个后继，除了第一个和最后一个元素之外，其它元素都是首尾相接的。</p>
<h3 id="List数据结构的基本概念"><a href="#List数据结构的基本概念" class="headerlink" title="List数据结构的基本概念"></a>List 数据结构的基本概念</h3><ul>
<li><strong>定义</strong>：List 是一种允许重复元素的序列，它可以维护元素插入的顺序。</li>
<li><strong>特点：</strong><ul>
<li><strong>动态大小：</strong>List 的大小不是固定的，它可以根据需要增长或缩小。</li>
<li><strong>有序集合：</strong>每个元素都有其特定的位置（索引）。</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h3 id="List的重要性"><a href="#List的重要性" class="headerlink" title="List的重要性"></a>List 的重要性</h3><ul>
<li><strong>灵活性</strong>：List 比数组更加灵活，可以轻松地添加、删除和访问元素。</li>
<li><strong>应用广泛</strong>：从简单的客户端应用程序到复杂的企业级解决方案，List 在各种场景下都非常有用。</li>
</ul>
<h3 id="List的常见操作"><a href="#List的常见操作" class="headerlink" title="List的常见操作"></a>List 的常见操作</h3><ul>
<li><strong>添加元素</strong>：可以在 List 的任意位置添加元素。</li>
<li><strong>删除元素</strong>：可以删除指定位置或指定值的元素。</li>
<li><strong>查找元素</strong>：可以搜索 List 中的元素，并返回其位置。</li>
<li><strong>遍历元素</strong>：可以遍历 List 中的所有元素。</li>
</ul>
<h3 id="List抽象接口"><a href="#List抽象接口" class="headerlink" title="List抽象接口"></a><strong>List 抽象接口</strong></h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;E&gt; {</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此列表中指定位置的元素。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 列表中指定的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下标中包含的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将此列表中指定位置的元素替换为指定元素（可选操作）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e     原来下标中的旧值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在此列表中的指定位置插入指定元素（可选操作）。</span></span><br><span class="line"><span class="comment">     * 将当前位于该位置的元素（如果有）和任何后续元素向右移动（将其索引加一）。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定元素追加到此列表的末尾（可选操作）。</span></span><br><span class="line"><span class="comment">     * 支持此操作的列表可能会对可以添加到此列表的元素进行限制。</span></span><br><span class="line"><span class="comment">     * 特别是，一些列表将拒绝添加空元素，而另一些列表将对可能添加的元素的类型施加限制。</span></span><br><span class="line"><span class="comment">     * 列表类应在其文档中明确指定对可以添加的元素的任何限制</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 列表中是否包含元素e</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(E o)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此列表包含指定元素，则返回 &lt;tt&gt;true&lt;tt&gt;。</span></span><br><span class="line"><span class="comment">     * 更正式地说，当且仅当此列表包含至少一个元素 &lt;tt&gt;e&lt;tt&gt;</span></span><br><span class="line"><span class="comment">     * 且满足 &lt;tt&gt;(o==null ? e==null : o.equals(e ))&lt;tt&gt;。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(E o)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除此列表中指定位置的元素（可选操作）。</span></span><br><span class="line"><span class="comment">     * 将所有后续元素向左移动（从索引中减去 1）。返回从列表中删除的元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从此列表中删除第一次出现的指定元素（如果存在）（可选操作）。</span></span><br><span class="line"><span class="comment">     * 如果此列表不包含该元素，则它不会更改。更正式地说，删除具有最低索引i 的元素，</span></span><br><span class="line"><span class="comment">     * 使得(o==null ? get(i)==null : o.equals(get(i))) （如果存在这样的元素）。</span></span><br><span class="line"><span class="comment">     * 如果此列表包含指定的元素（或者等效地，如果此列表由于调用的结果而更改），则返回true 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(E o)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此列表中的元素数量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此列表不包含任何元素，则返回true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong>数组实现 List 的数据结构基础</strong></p>
<ul>
<li>默认容量 DEFAULT_CAPACITY</li>
<li> 可共享的空实例数组 EMPTY_ELEMENTDATA</li>
<li> 真正存放数据的数组 elementData</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组允许分配的最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可共享的空实例数组 capacity == 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = {};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 底层数据结构 数组 真正存放数据的数据结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="List初始化"><a href="#List初始化" class="headerlink" title="List初始化"></a>List 初始化</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 初始化数组大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> {</span><br><span class="line">    <span class="comment">// 直接初始化</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        <span class="comment">// 设置共享成员变量</span></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"Illegal Capacity: "</span> + initialCapacity);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> {</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="add添加元素"><a href="#add添加元素" class="headerlink" title="add添加元素"></a>add <strong>添加元素</strong></h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> {</span><br><span class="line">    <span class="comment">// 确保申请的底层数组的容量可以存入当前这个元素</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 将元素插入数组 并将size+1</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 确保底层数组的容量是大于当前需要的最小容量</span></span><br><span class="line"><span class="comment"> * 如果容量不够就进行扩容</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity 所需最小容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> {</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算容量 选择默认容量和所需容量中的较大者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> {</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否需要扩容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">// 默认增加原有素组大小的一半</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 选择 newCapacity 和 minCapacity 中的较大者</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新数组大于我们设定的最大数组长度 MAX_ARRAY_SIZE 则重新计算新数组大小</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 申请一个新的数组 数组大小为 newCapacity  并将原来数组的中数据拷贝到新数组</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以申请的最大内存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> {</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="一维数组插入数据GIF动图"><a href="#一维数组插入数据GIF动图" class="headerlink" title="一维数组插入数据GIF动图"></a><strong>一维数组插入数据 GIF 动图</strong></h3><p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-f7be2c419b1bde72bc6bae4797192ef8_1440w.gif" alt="img"></p>
<h3 id="一维数组扩容"><a href="#一维数组扩容" class="headerlink" title="一维数组扩容"></a><strong>一维数组扩容</strong></h3><p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-91ce3f09ff005fef4c3f79e32d7806fc_1440w-20240202212514681.png" alt="新申请一个数组，将旧值复制到新数组中"></p>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-404876b6399612ed0a07e84234802b1b_1440w.png" alt="使用新数组取代旧数组"></p>
<h3 id="Java数组扩容实现"><a href="#Java数组扩容实现" class="headerlink" title="Java数组扩容实现"></a>Java 数组扩容实现</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">// 默认增加原有素组大小的一半</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 选择 newCapacity 和 minCapacity 中的较大者</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新数组大于我们设定的最大数组长度 MAX_ARRAY_SIZE 则重新计算新数组大小</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 申请一个新的数组 数组大小为 newCapacity  并将原来数组的中数据拷贝到新数组</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="add指定位置插入元素"><a href="#add指定位置插入元素" class="headerlink" title="add指定位置插入元素"></a>add 指定位置<strong>插入元素</strong></h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> {</span><br><span class="line">    <span class="comment">// 确保index的位置是合法的</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从待插入元素位置开始到结尾的所有元素 向后移动一个位置，将待插入位置空出</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">            size - index);</span><br><span class="line">    <span class="comment">// 设置元素</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="comment">// 数量+1</span></span><br><span class="line">    size++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheckForAdd</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="set替换元素"><a href="#set替换元素" class="headerlink" title="set替换元素"></a>set <strong>替换元素</strong></h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> {</span><br><span class="line">    <span class="comment">// 检查下标是否越界</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">// 旧值</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    <span class="comment">// 插入新值</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="comment">// 返回旧值</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="remove删除元素"><a href="#remove删除元素" class="headerlink" title="remove删除元素"></a>remove <strong>删除元素</strong></h3><p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-c651b2ea3de1359e3f7e252866fbd468_1440w-20240202212602109.png" alt="计算要移动的元素"></p>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-3200fc986303b9036f8832ad51a35f88_1440w.png" alt="移动元素，覆盖要删除的数据"></p>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-92212204942490230aa4f166fb07e99d_1440w-20240202213325202.png" alt="置空数据"></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">    <span class="comment">// 判断待删除元素下标是否越界</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待删除的旧值</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算需要移动位置元素的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 移动位置</span></span><br><span class="line">        System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index,</span><br><span class="line">                numMoved);</span><br><span class="line">    <span class="comment">// size-1 </span></span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回删除元素</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="github项目"><a href="#github项目" class="headerlink" title="github项目"></a><a href="https://github.com/nadav-cheung/algorithm">github 项目</a></h2>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>ArrayList</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>List</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>《线性搜索算法》</title>
    <url>/posts/dea6490e/</url>
    <content><![CDATA[<h2 id="《算法与数据结构-线性搜索算法》"><a href="#《算法与数据结构-线性搜索算法》" class="headerlink" title="《算法与数据结构:线性搜索算法》"></a>《算法与数据结构：线性搜索算法》</h2><h2 id="线性搜索算法"><a href="#线性搜索算法" class="headerlink" title="线性搜索算法"></a>线性搜索算法</h2><p>当我们谈论搜索算法时，线性搜索算法因其简单性和直接性而占据了一个重要的位置。这种算法在编程和数据处理中非常常见，尤其是在处理未排序的数据集时。本文将详细介绍线性搜索算法的基本原理，并提供 Java 语言的实现示例。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>线性搜索，又被称为顺序搜索，是一种在数据结构（如数组或列表）中查找特定元素的方法。这种搜索从数据结构的一端开始，顺序检查每个元素，直到找到所需的元素或搜索完所有元素为止。</p>
<span id="more"></span>

<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-f132f7f77eaa719405993b4d66c99d8a_1440w.png" alt="《算法与数据结构：线性搜索算法》"></p>
<h3 id="线性搜索的特点"><a href="#线性搜索的特点" class="headerlink" title="线性搜索的特点"></a><strong>线性搜索的特点</strong></h3><ul>
<li><strong>简单性</strong>：它是最基本、最简单的搜索算法之一。</li>
<li><strong>无需预处理</strong>：不像其他高级搜索算法（如二分搜索），线性搜索不需要数据预先排序。</li>
<li><strong>时间复杂度</strong>：在最坏的情况下，线性搜索的时间复杂度为 O (n)，其中 n 是数据结构中元素的数量。这意味着在最糟糕的情况下，算法可能需要检查数据结构中的每个元素。</li>
</ul>
<h3 id="线性搜索算法的适用场景"><a href="#线性搜索算法的适用场景" class="headerlink" title="线性搜索算法的适用场景"></a><strong>线性搜索算法的适用场景</strong></h3><p>虽然线性搜索不是最快的搜索方法，但在某些情况下它是非常有用的：</p>
<ul>
<li>当数据量较小或者数据未排序时。</li>
<li>当要搜索的元素可能接近数据结构的开始位置时。</li>
<li>在某些复杂数据结构中，其他搜索方法可能不可行时。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == target) {</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>Java 范型实现</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> E&gt;&gt; <span class="type">int</span> <span class="title function_">search</span><span class="params">(E[] nums, E target)</span> {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">        <span class="keyword">if</span> (nums[i].compareTo(target) == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="github项目"><a href="#github项目" class="headerlink" title="github项目"></a><a href="https://github.com/nadav-cheung/algorithm">github 项目</a></h2>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>线性搜索算法</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>线性搜索算法</tag>
      </tags>
  </entry>
  <entry>
    <title>《二分搜索算法》</title>
    <url>/posts/86e9784a/</url>
    <content><![CDATA[<h2 id="《算法与数据结构-二分搜索算法》"><a href="#《算法与数据结构-二分搜索算法》" class="headerlink" title="《算法与数据结构:二分搜索算法》"></a>《算法与数据结构：二分搜索算法》</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>二分搜索算法是一种在有序数组中查找特定元素的有效方法。其基本思想是通过将搜索区间分成两半，然后根据目标值与中间元素的比较结果来选择搜索的半区，从而逐步缩小搜索范围，直到找到目标值或确定目标值不存在。</p>
<h3 id="二分搜索的工作原理"><a href="#二分搜索的工作原理" class="headerlink" title="二分搜索的工作原理"></a><strong>二分搜索的工作原理</strong></h3><p>二分搜索（又称二分查找）是一种在有序数组中查找特定元素的算法。在 Java 中实现二分搜索，你可以遵循以下步骤：</p>
<p><strong>确定查找范围</strong>：设置两个指针，low 和 high，分别表示数组的起始和结束位置 nums [low,high) 左闭右开区间。</p>
<p><strong>计算中间位置</strong>：在每次迭代中，计算中间位置 mid = low + (high - low) / 2。</p>
<p><strong>比较和移动指针</strong>：</p>
<ul>
<li>如果 arr [mid] 等于目标值，返回 mid。</li>
<li>如果 arr [mid] 小于目标值，说明目标值在数组的右半部分，将 low 更新为 mid + 1。</li>
<li>如果 arr [mid] 大于目标值，说明目标值在数组的左半部分，将 high 更新为 mid。</li>
</ul>
<p><strong>重复步骤 2 和 3</strong>，直到 low 超过 high，表示找不到目标值，返回 -1。</p>
<span id="more"></span>

<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-448e035dc82ae215865e0319f238363e_1440w.png" alt="img"></p>
<h3 id="二分搜索的优势"><a href="#二分搜索的优势" class="headerlink" title="二分搜索的优势"></a><strong>二分搜索的优势</strong></h3><ul>
<li><strong>效率高</strong>：二分搜索的时间复杂度为 O (log n)，远高于线性搜索的 O (n)。</li>
<li><strong>适用范围广</strong>：适用于任何可以快速访问元素的有序数组。</li>
</ul>
<h3 id="Java二分搜索递归实现"><a href="#Java二分搜索递归实现" class="headerlink" title="Java二分搜索递归实现"></a><strong>Java 二分搜索递归实现</strong></h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分搜索（又称二分查找）是一种在有序数组中查找特定元素的算法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array  有序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 目标数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> array index 不存在则返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">recursionSearch</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="keyword">return</span> recursionSearch(array, <span class="number">0</span>, array.length, target);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array  数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> l      左边界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> r      右边界 初始化时等于数组长度  array[l,r)左闭右开区间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">recursionSearch</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> target)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// array[l,r) 在左闭右开区间中寻找 target</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) {</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (array[mid] == target) {</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (array[mid] &lt; target) {</span><br><span class="line">        <span class="keyword">return</span> recursionSearch(array, mid + <span class="number">1</span>, r, target);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// it means array[mid] &gt; target</span></span><br><span class="line">    <span class="keyword">return</span> recursionSearch(array, l, mid, target);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="二分搜索递归范型实现"><a href="#二分搜索递归范型实现" class="headerlink" title="二分搜索递归范型实现"></a>二分搜索递归范型实现</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Java范型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> E&gt;&gt; <span class="type">int</span> <span class="title function_">recursionSearch</span><span class="params">(E[] array, E target)</span> {</span><br><span class="line">    <span class="keyword">return</span> recursionSearch(array, <span class="number">0</span>, array.length, target);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> E&gt;&gt; <span class="type">int</span> <span class="title function_">recursionSearch</span><span class="params">(E[] array, <span class="type">int</span> l, <span class="type">int</span> r, E target)</span> {</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) {</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (array[mid].compareTo(target) == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (array[mid].compareTo(target) &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> recursionSearch(array, mid + <span class="number">1</span>, r, target);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> recursionSearch(array, l, mid, target);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="二分搜索迭代实现"><a href="#二分搜索迭代实现" class="headerlink" title="二分搜索迭代实现"></a>二分搜索<strong>迭代实现</strong></h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 迭代实现</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">iterationSearch</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> target)</span> {</span><br><span class="line">      <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> array.length;</span><br><span class="line">      <span class="comment">// 在 array[l,r）中寻找target</span></span><br><span class="line">      <span class="keyword">while</span> (l &lt; r) {</span><br><span class="line">          <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">if</span> (array[mid] == target) {</span><br><span class="line">              <span class="keyword">return</span> mid;</span><br><span class="line">          } <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &lt; target) {</span><br><span class="line">              l = mid + <span class="number">1</span>;</span><br><span class="line">          } <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &gt; target) {</span><br><span class="line">              r = mid;</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="二分搜索迭代范型实现"><a href="#二分搜索迭代范型实现" class="headerlink" title="二分搜索迭代范型实现"></a>二分搜索迭代范型实现</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> E&gt;&gt; <span class="type">int</span> <span class="title function_">iterationSearch</span><span class="params">(E[] array, E target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> array.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 array[l,r）中寻找target  l&gt;=r 跳出</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (array[mid].compareTo(target) == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (array[mid].compareTo(target) &lt; <span class="number">0</span>) {</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (array[mid].compareTo(target) &gt; <span class="number">0</span>) {</span><br><span class="line">            r = mid;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="二分搜索算法实战"><a href="#二分搜索算法实战" class="headerlink" title="二分搜索算法实战"></a>二分搜索算法实战</h3><h2 id="实现-leftBound"><a href="#实现-leftBound" class="headerlink" title="实现 leftBound"></a><strong>实现</strong> <strong> leftBound</strong></h2><p>在算法中，leftBound 是一个基于二分搜索法的变种，其目的是确定在一个有序数组中目标元素的 “最左边界” 位置。这意味着，如果数组中有多个相同的目标元素，leftBound 将返回第一个出现这个元素的索引。如果目标元素不存在于数组中，leftBound 将返回 - 1，以保持数组的有序性。这是一种在有序数据集中快速定位元素的高效方法。</p>
<p>leftBound 的实现需要细微调整普通二分搜索的逻辑。关键点在于如何处理找到目标值的情况：即使找到了目标值，我们也继续搜索其左侧区域，以确保找到的是最左边的匹配项。</p>
<p>以下是使用 Java 语言实现 leftBound 的步骤：</p>
<ol>
<li><strong>初始化指针</strong>：设定两个指针 low 和 high，分别指向数组的起始位置和末尾位置的下一位。nums [low,high) 左闭右开区间</li>
<li><strong>开始二分搜索</strong>：</li>
</ol>
<ul>
<li>计算中间位置 mid。</li>
<li>如果 mid 位置的元素小于目标值，将 low 移至 mid + 1。</li>
<li>如果 mid 位置的元素大于等于目标值，将 high 移至 mid。</li>
<li><strong>检查和返回结果</strong>：</li>
<li>搜索结束后，low 将指向目标值的最左边界或者目标值应该插入的位置。</li>
<li>需要检查 low 是否在数组范围内且是否等于目标值，以确认是否找到目标值。</li>
</ul>
<h3 id="实现方式一-左闭右开区间"><a href="#实现方式一-左闭右开区间" class="headerlink" title="实现方式一 左闭右开区间"></a><strong>实现方式一 左闭右开区间</strong></h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Java binary search left bound refers to finding the first occurrence of a target value in a sorted array.</span></span><br><span class="line"><span class="comment">     * This can be done using binary search, which has a time complexity of O(log n). Here's an example implementation:</span></span><br><span class="line"><span class="comment">     * 在一个可重复的有序数组中寻找第一次出现的元素</span></span><br><span class="line"><span class="comment">     * 不断向左边逼近</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">leftBound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// nums[left,right) 左闭右开区间查询</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) {</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                right = mid;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  // Check if we found the desired number and 'left' is within bounds. 越界问题分析</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target) {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="实现方式二-左闭右闭区间"><a href="#实现方式二-左闭右闭区间" class="headerlink" title="实现方式二 左闭右闭区间"></a><strong>实现方式二 左闭右闭区间</strong></h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 实现方式二 左闭右闭区间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findLeftBound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perform binary search</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nums[l,r] 左闭右闭区间</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if we found the desired number and 'left' is within bounds.</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; nums.length &amp;&amp; nums[left] == target)</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// Target not found in the array</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="实现-rightBound"><a href="#实现-rightBound" class="headerlink" title="实现 rightBound"></a><strong>实现</strong> <strong> rightBound</strong></h2><p>rightBound 是二分搜索算法的另一种变体，用于找到目标值在有序数组中的 “最右边界” 位置。如果数组中存在多个相同的目标元素，rightBound 返回最后一个出现这个元素的索引。如果目标元素不存在于数组中，rightBound 会返回 - 1。这是一种在有序数据集中快速定位元素的高效方法。</p>
<p>rightBound 的实现与普通的二分搜索有细微的区别。当找到目标值时，而不是立即返回，算法会继续在右侧区间搜索，以确保找到的是最右边的匹配项。</p>
<p>以下是使用 Java 语言实现 rightBound 的步骤：</p>
<ol>
<li><strong>初始化指针</strong>：设定两个指针 low 和 high，分别指向数组的起始位置和末尾位置。</li>
<li><strong>开始二分搜索</strong>：</li>
</ol>
<ul>
<li>计算中间位置 mid。</li>
<li>如果 mid 位置的元素小于等于目标值，将 low 移至 mid + 1。</li>
<li>如果 mid 位置的元素大于目标值，将 high 移至 mid。</li>
<li><strong>检查和返回结果</strong>：</li>
<li>由于循环中 low 可能会超过目标值的最右边界，所以最后需要将 low 减去 1 以指向正确的位置。</li>
<li>检查减去 1 后的 low 是否在数组范围内且是否等于目标值。</li>
</ul>
<h3 id="实现方式一-左闭右开区间-1"><a href="#实现方式一-左闭右开区间-1" class="headerlink" title="实现方式一 左闭右开区间"></a><strong>实现方式一 左闭右开区间</strong></h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rightBound</span><span class="params">(<span class="type">int</span>[] data, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">null</span> || data.length == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> data.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// data[l,r)</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (data[mid] == target) {</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (data[mid] &lt; target) {</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (data[mid] &gt; target) {</span><br><span class="line">            r = mid;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// l&gt;=r 跳出条件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; data[r - <span class="number">1</span>] == target) {</span><br><span class="line">        <span class="keyword">return</span> r - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="实现方式二-左闭右闭区间-1"><a href="#实现方式二-左闭右闭区间-1" class="headerlink" title="实现方式二 左闭右闭区间"></a><strong>实现方式二 左闭右闭区间</strong></h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findRightBound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perform binary search</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nums[l,r] 左闭右闭区间</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if we found the desired number and 'right' is within bounds.</span></span><br><span class="line">    <span class="keyword">if</span> (right &gt;= <span class="number">0</span> &amp;&amp; nums[right] == target)</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// Target not found in the array</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a><strong>插值查找</strong></h2><p><strong>（Interpolation Search）</strong>是一种搜索算法，它是二分搜索的改进。在插值查找中，我们根据要查找的键值对搜索区间进行划分，而不是总是对半分。这种方法对于分布均匀的有序数组是非常高效的。</p>
<h3 id="插值查找原理"><a href="#插值查找原理" class="headerlink" title="插值查找原理"></a>插值查找原理</h3><p>插值查找的核心思想是在每次比较时，使用数据分布的信息来预测键值可能存在的位置。它通过一个插值公式来计算可能的位置，而不是总是查找中间位置。如果元素均匀分布，插值查找的平均时间复杂度可以更接近 O (log log n)。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertValueSearch</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插值查找</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr    有序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> low    搜索的低索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> high   搜索的高索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 要查找的目标值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 目标值的索引或-1（如果不存在）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">interpolationSearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> target)</span> {</span><br><span class="line">        <span class="keyword">if</span> (low &lt;= high &amp;&amp; target &gt;= arr[low] &amp;&amp; target &lt;= arr[high]) {</span><br><span class="line">            <span class="comment">// 计算插值位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> low + ((target - arr[low]) * (high - low)) / (arr[high] - arr[low]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (arr[pos] == target) {</span><br><span class="line">                <span class="keyword">return</span> pos;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (arr[pos] &lt; target) {</span><br><span class="line">                <span class="keyword">return</span> interpolationSearch(arr, pos + <span class="number">1</span>, high, target);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> interpolationSearch(arr, low, pos - <span class="number">1</span>, target);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] arr = {<span class="number">10</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">33</span>, <span class="number">35</span>, <span class="number">42</span>, <span class="number">47</span>};</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> interpolationSearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, target);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index != -<span class="number">1</span>) {</span><br><span class="line">            System.out.println(<span class="string">"元素 "</span> + target + <span class="string">" 的索引是: "</span> + index);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            System.out.println(<span class="string">"元素 "</span> + target + <span class="string">" 在数组中不存在。"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这段代码中，interpolationSearch 方法实现了插值查找的逻辑。需要注意的是，由于插值查找依赖于数据的分布，因此它在处理非均匀分布的数据时效率不如二分搜索。</p>
<p>在实际应用中，选择使用插值搜索还是二分搜索取决于数据的特性。</p>
<h2 id="github项目"><a href="#github项目" class="headerlink" title="github项目"></a><a href="https://github.com/nadav-cheung/algorithm">github 项目</a></h2>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>二分搜索算法</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>二分搜索算法</tag>
      </tags>
  </entry>
  <entry>
    <title>《HeapSort》</title>
    <url>/posts/607bf52d/</url>
    <content><![CDATA[<h2 id="《算法与数据结构-HeapSort》"><a href="#《算法与数据结构-HeapSort》" class="headerlink" title="《算法与数据结构:HeapSort》"></a>《算法与数据结构：HeapSort》</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>堆排序是一种高效的排序算法，它利用了堆的数据结构特性来排序元素。在堆排序中，首先将待排序的序列构造成一个堆，然后将堆顶的最大（或最小）元素与堆尾元素交换，然后调整堆结构，继续选择堆顶的元素，直到序列排序完成。</p>
<h3 id="堆的类型和性质"><a href="#堆的类型和性质" class="headerlink" title="堆的类型和性质"></a>堆的类型和性质</h3><ul>
<li><strong>最大堆</strong>：父节点的值总是大于或等于子节点的值。在数组中，对于每个元素 <code>i</code>，其子节点位于 2 * i + 1 和 <code>2 * i + 2</code>。</li>
<li><strong>最小堆</strong>：父节点的值总是小于或等于子节点的值。同样地，子节点的位置与最大堆相同。</li>
<li><strong>性质</strong>：堆总是一棵完全二叉树。这意味着除了最底层，每层都是完全填满的，而最底层则尽可能地从左到右填满。</li>
</ul>
<h3 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h3><p><a href="https://nadav.com.cn/posts/5eb18949/">堆前置知识</a></p>
<p>在 Java 中，可以使用数组来实现堆。数组中的每个位置对应堆中的一个节点，父节点和子节点的位置关系可以通过数组索引轻松找到。这种数据结构使得堆操作的时间复杂度保持在对数级别。</p>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-35f567686fae868e742dcdabc49584cb_r.jpg" alt="img"></p>
<span id="more"></span>

<h3 id="堆排序算法步骤"><a href="#堆排序算法步骤" class="headerlink" title="堆排序算法步骤"></a>堆排序算法步骤</h3><ol>
<li><strong>构建堆</strong>：将给定数组构建成最大堆（或最小堆）。</li>
<li><strong>排序</strong>：将堆顶元素（最大或最小）与堆的最后一个元素交换，然后减小堆的大小并重新调整堆，重复这个过程直至堆为空。</li>
<li><strong>构建堆的过程</strong>：将一个无序数组转换成一个堆。这通常通过 “堆化” 过程实现，即从最后一个非叶子节点开始向上调整，确保每个子树都遵循堆的性质。</li>
<li><strong>堆排序的过程</strong>：移除堆顶元素（最大或最小），将其放置在数组的末尾，然后重新调整剩余元素以维持堆的性质。重复这一过程直到所有元素都被排序。</li>
</ol>
<h3 id="堆排序示例"><a href="#堆排序示例" class="headerlink" title="堆排序示例"></a>堆排序示例</h3><p><strong>对整数数组进行堆排序</strong></p>
<p>考虑数组 <code>[10, 18, 8, 7, 12, 5, 16]</code>，我们希望通过堆排序对其进行排序。</p>
<p><strong>构建最大堆</strong>：</p>
<ul>
<li>开始时，数组表示为 <code>[10, 18, 8, 7, 12, 5, 16]</code>。</li>
<li>对数组进行堆化，构建最大堆。</li>
<li>经过调整，得到最大堆：<code>[18, 12, 16, 7, 10, 5, 8]</code>。</li>
</ul>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-1846e05c157f690b8ba25dc77941ad60_1440w-20240202205726159.png" alt="img"></p>
<p><strong>排序过程</strong>：</p>
<ul>
<li>完成堆排序的数组是：<code>[18, 12, 16, 7, 10, 5, 8]</code>。</li>
<li>将堆顶元素（18）与最后一个元素（8）交换：<code>[8, 12, 16, 7, 10, 5, 18]</code>。</li>
<li>将除去最后一个元素（已排序部分）的剩余部分调整为最大堆：<code>[16, 12, 8 7, 10, 5] | [18]</code>。</li>
<li>再次将堆顶元素（16）与最后一个元素（5）交换：<code>[6, 12, 8 7, 10, 16] | [18]</code>。</li>
<li>将除去最后一个元素（已排序部分）的剩余部分调整为最大堆：<code>[12, 10 8, 7, 5] | [16, 18]</code> </li>
<li>继续这个过程，直到所有元素都被排序：最终数组为 <code>[5, 7, 8, 10, 12, 16, 18]</code>。</li>
</ul>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-5b7484f89e1ae103972179cf79c73624_1440w-20240202205726280.png" alt="img"></p>
<p>在这个过程中，每次都将最大元素移至数组的末尾，并在剩余的数组部分重建最大堆，直到所有元素都被排序。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p><strong>建堆 heapify</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(T[] nums, <span class="type">int</span> length)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (length &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        siftDownComparable(i, nums[i], nums, length);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>下沉 siftDown</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在位置 k 处插入项 x，通过将 x 沿着树重复降级直到它小于或等于其子项或者是叶子来保持堆不变性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDownComparable</span><span class="params">(<span class="type">int</span> k, T x, T[] nums, <span class="type">int</span> length)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> length &gt;&gt;&gt; <span class="number">1</span>;           <span class="comment">// loop while a non-leaf</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 x 沿着树重复降级直到它大于或等于其子项或者是叶子来保持堆不变性。</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) {</span><br><span class="line">        <span class="comment">// 记录两个孩子节点中的较大节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> leftChild(k); <span class="comment">// assume left child is least</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录 两个孩子节点中的较大者</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">c</span> <span class="operator">=</span> nums[child];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右边孩子节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> child + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右边孩子节点存在 并且 左边孩子节点大于右边孩子节点 寻找两个孩子节点中的较小者</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; length &amp;&amp; c.compareTo(nums[right]) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 更新孩子节点和索引</span></span><br><span class="line">            c = nums[child = right];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 满足堆的性质</span></span><br><span class="line">        <span class="keyword">if</span> (x.compareTo(c) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不满足性质 在k的位置插入较大的孩子节点c</span></span><br><span class="line">        nums[k] = c;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// x 沿着树降级 将k更新为较大的孩子节点 尝试在k处重新插入x</span></span><br><span class="line">        k = child;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 跳出循环 在位置 k 处插入项 x，</span></span><br><span class="line">    nums[k] = x;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>堆排序 Sort</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(T[] nums)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建最大堆</span></span><br><span class="line">    heapify(nums, length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐个从堆顶取出元素到数组末尾，完成排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) {</span><br><span class="line">        <span class="comment">// 队尾元素</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">heapTail</span> <span class="operator">=</span> nums[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出堆顶元素 放入堆尾</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">heapHead</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        nums[i] = heapHead;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在堆顶插入队尾元素 这时候会违反堆的元素 执行siftDown</span></span><br><span class="line">        siftDownComparable(<span class="number">0</span>, heapTail, nums, i);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>时间复杂度</strong>：平均和最坏情况下都是 O (nlogn)。</li>
<li><strong>空间复杂度</strong>：O (1)，因为它是就地排序。</li>
<li><strong>不稳定性</strong>：堆排序是一种不稳定的排序算法，因为在堆顶的元素与子树的最后一个元素交换时，可能会改变相等元素的初始顺序。</li>
</ul>
<p>理解堆排序主要就是理解堆的特性和 <strong>siftDown</strong> 操作原理</p>
<h2 id="github项目"><a href="#github项目" class="headerlink" title="github项目"></a><a href="https://github.com/nadav-cheung/algorithm">github 项目</a></h2>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>HeapSort</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>堆</tag>
        <tag>堆排序</tag>
      </tags>
  </entry>
  <entry>
    <title>《字符串搜索算法》</title>
    <url>/posts/b238ed84/</url>
    <content><![CDATA[<h2 id="《算法与数据结构-字符串搜索算法》"><a href="#《算法与数据结构-字符串搜索算法》" class="headerlink" title="《算法与数据结构:字符串搜索算法》"></a>《算法与数据结构：字符串搜索算法》</h2><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>字符串匹配是计算机科学中一个基础而重要的问题，它涉及在一个文本字符串中寻找一个子字符串的过程。这一问题在许多领域都有广泛的应用，包括文本编辑、生物信息学、数据检索等。在众多解决字符串匹配问题的算法中，KMP（Knuth-Morris-Pratt）算法因其高效的匹配过程而著称。不同于传统的朴素匹配方法，KMP 算法利用已匹配的部分信息避免从头开始匹配，大大提高了搜索效率。本文旨在为初学者提供一个关于 KMP 算法的入门指南，介绍其基本概念、工作原理及应用场景。</p>
<h3 id="字符串匹配基础"><a href="#字符串匹配基础" class="headerlink" title="字符串匹配基础"></a>字符串匹配基础</h3><p>字符串匹配是指在一个较长的文本字符串中查找一个指定的子字符串的过程。这个问题看似简单，实则是许多计算机应用的核心部分，例如，在一个大型文档中查找特定单词，或者在网页搜索中定位关键词。字符串匹配的效率直接影响到这些应用的性能和用户体验。</p>
<span id="more"></span>

<h3 id="朴素字符串匹配算法"><a href="#朴素字符串匹配算法" class="headerlink" title="朴素字符串匹配算法"></a>朴素字符串匹配算法</h3><p>最直观的字符串匹配方法是朴素字符串匹配算法。该算法从文本的第一个字符开始，逐个字符地将子字符串与文本中的连续字符段进行比较。如果所有字符都匹配，则认为找到了一个匹配位置；如果某个字符不匹配，则算法将子字符串向前移动一个字符，再次从头开始比较。</p>
<h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>尽管朴素的字符串匹配算法易于理解和实现，但它在处理大型文本时效率较低。特别是当文本和子字符串较长，且匹配失败仅在子字符串的末尾时，朴素算法会进行大量的重复比较。这种低效率在数据量大或需要频繁执行匹配操作的应用中尤为突出。</p>
<h2 id="字符串暴力搜索"><a href="#字符串暴力搜索" class="headerlink" title="字符串暴力搜索"></a>字符串暴力搜索</h2><p>字符串暴力搜索，又称朴素搜索算法，是一种基础且直观的字符串匹配方法。它尝试在一个主字符串（文本）中查找一个子字符串（模式），通过逐个字符比较来检查子字符串是否出现在主字符串中。让我们用一个简单的例子来说明暴力搜索的过程：</p>
<h3 id="暴力搜索的步骤"><a href="#暴力搜索的步骤" class="headerlink" title="暴力搜索的步骤"></a>暴力搜索的步骤</h3><p>假设我们有一个主字符串 <code>S = "ABCDESD"</code> 和一个要搜索的子字符串<code> P = "ES"</code>。我们的目标是找到子字符串 <code>P</code> 在主字符串 <code>S</code> 中的位置（如果存在的话）。</p>
<p><strong>初始化索引</strong>：我们从主字符串 <code>S</code> 的第一个字符开始，设主字符串的当前索引为<code> i = 0</code>，子字符串的当前索引为<code> j = 0</code>。</p>
<p><strong>字符比较</strong>：比较 <code>S[i]</code> 和 <code>P[j]</code>：</p>
<ul>
<li>如果 <code>S[i] == P[j]</code>，我们将两个索引 <code>i</code> 和 <code>j</code> 同时增加<code> 1</code>，继续比较下一个字符。</li>
<li>如果 <code>S[i] != P[j]</code>，我们发现一个不匹配。此时，我们将子字符串 <code>P </code>的索引 <code>j </code>重置为<code> 0</code>，并将主字符串 <code>S</code> 的索引 <code>i </code>回溯到这次匹配尝试的起始位置的下一个字符（即 <code>i = i - j + 1</code>）。</li>
</ul>
<p><strong>检查完整匹配</strong>：每次当<code> j</code> 达到子字符串 <code>P</code> 的长度时，意味着我们找到了一个完整的匹配。记录下这个位置，然后像在不匹配的情况下一样，重置 <code>j </code>为 <code>0</code>，并调整 <code>i</code>。</p>
<p><strong>重复过程</strong>：重复以上步骤，直到主字符串<code> S</code> 的末尾。</p>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>让我们通过一个简化的例子来具体说明暴力搜索的过程：</p>
<ul>
<li>假设 <code>S = "ABCABCDABABCDABCDABDE"</code>，<code>P = "ABCDABD"</code>。</li>
<li>开始时，<code>i = 0，j = 0</code>，<code>S[i]</code> 与 <code>P[j]</code> 匹配，继续向前比较。</li>
<li>当 <code>i =3</code>，<code>j =3</code> 时，<code>S[i]</code> 与 <code>P[j]</code> 不匹配。此时，我们将 <code>i</code> 回溯到 <code>1</code>，<code>j</code> 重置为 <code>0</code>。</li>
<li>这个过程一直持续，直到我们找到完整的匹配或遍历完整个主字符串。</li>
</ul>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-6fa6da89e6812ad269034bdfa28ef74b_1440w-20240202204711695.png" alt="图1:暴力搜索算法示例简化图"></p>
<h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><p>暴力搜索算法的时间复杂度通常是 <code>O(n*m)</code>，其中 <code>n</code> 是文本的长度，<code>m</code> 是模式的长度。在最坏的情况下，我们可能需要将模式与文本中的每个可能的位置进行比较。然而，在实际应用中，特别是当模式较短或在文本中较早出现时，暴力搜索的效率可能比理论上的最坏情况要好。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bruteForce</span><span class="params">(String source, String pattern)</span> {</span><br><span class="line">    <span class="keyword">if</span> (source.length() &lt; pattern.length()) {</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s[i,i+pattern.length-1] == pattern 判断s的子串是否和t相同</span></span><br><span class="line">    <span class="comment">// aaaa</span></span><br><span class="line">    <span class="comment">//   aa</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i + pattern.length() - <span class="number">1</span> &lt; source.length(); i++) {</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; pattern.length(); j++) {</span><br><span class="line">            <span class="keyword">if</span> (source.charAt(i + j) != pattern.charAt(j)) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (j == pattern.length()) {</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>尽管暴力搜索效率不高，但在一些特定场景下，例如短字符串的搜索或者数据量不大时，它仍然是一个可行的选择。此外，暴力搜索算法的实现简单，不需要预处理文本或模式，也不需要额外的存储空间，这使得它在某些资源受限的环境下仍然有其应用价值。</p>
<h2 id="KMP算法概述"><a href="#KMP算法概述" class="headerlink" title="KMP算法概述"></a>KMP 算法概述</h2><p><code>KMP算法</code>，由 <code>Donald Knuth、Vaughan Pratt和James H. Morris</code> 共同发明，是解决字符串匹配问题的一个经典算法。它的核心思想是，当在文本字符串中出现不匹配的情况时，可以利用已匹配的部分信息，避免从头开始匹配，从而提高搜索效率。</p>
<h3 id="巧妙利用已匹配信息"><a href="#巧妙利用已匹配信息" class="headerlink" title="巧妙利用已匹配信息"></a>巧妙利用已匹配信息</h3><p>KMP 算法的关键在于构建一个称为” 部分匹配表”（<code>Partial Match Table）</code>或” 失败函数” 的数据结构，这个表包含了关于子字符串自身重复模式的信息。在匹配过程中，当遇到不匹配的字符时，算法会参考这个表来决定下一步应该将子字符串向前移动多远，而不是简单地每次只移动一个字符。</p>
<h3 id="高效性的来源"><a href="#高效性的来源" class="headerlink" title="高效性的来源"></a>高效性的来源</h3><p>这种方法大大减少了不必要的比较次数，特别是在处理包含大量重复模式的字符串时更为显著。KMP 算法的时间复杂度是线性的，即 <code>O(n+m)</code>，其中 <em>n</em> 是文本字符串的长度，<em>m</em> 是子字符串的长度。这使得 KMP 算法成为在实际应用中处理字符串匹配问题的一个高效选择。</p>
<h3 id="KMP算法核心原理"><a href="#KMP算法核心原理" class="headerlink" title="KMP算法核心原理"></a>KMP 算法核心原理</h3><p>KMP 算法的高效之处在于它能够在不匹配发生时，通过预先计算得到的部分匹配表来决定下一步匹配应该开始的位置，从而避免了不必要的比较。这一节将详细解释构成 KMP 算法核心的几个关键概念：前缀、后缀和部分匹配表。</p>
<h3 id="前缀和后缀"><a href="#前缀和后缀" class="headerlink" title="前缀和后缀"></a>前缀和后缀</h3><ul>
<li><strong>前缀</strong>：一个字符串的前缀是指从字符串的第一个字符开始的所有可能的子串。</li>
<li><strong>后缀</strong>：一个字符串的后缀是指以字符串的最后一个字符结束的所有可能的子串。</li>
</ul>
<p>在 KMP 算法中，通过比较子字符串的前缀和后缀，我们可以找到一些有用的模式，这些模式告诉我们在发生不匹配时如何有效地移动子字符串。</p>
<h3 id="部分匹配表"><a href="#部分匹配表" class="headerlink" title="部分匹配表"></a>部分匹配表</h3><p>部分匹配表（也称为” 失败函数”）是 KMP 算法中的核心数据结构。对于子字符串中的每个字符，部分匹配表记录了直到该字符为止的子字符串的前缀集合与后缀集合的最长公共元素的长度。这个长度告诉我们在不匹配发生时，子字符串应该向右移动多远。</p>
<h3 id="构建部分匹配表"><a href="#构建部分匹配表" class="headerlink" title="构建部分匹配表"></a>构建部分匹配表</h3><ul>
<li><strong>初始化</strong>：部分匹配表的第一个值总是 0，因为字符串的第一个字符没有前缀。</li>
<li><strong>迭代计算</strong>：对于子字符串中的每个后续字符，我们查找最长的相同前缀和后缀。这个过程可以通过递归地使用已计算的部分匹配表值来高效完成。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] computeLPSArray(String pattern) {</span><br><span class="line">    <span class="type">int</span>[] lps = <span class="keyword">new</span> <span class="title class_">int</span>[pattern.length()];</span><br><span class="line">    lps[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 最长公共前缀和后缀的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; pattern.length()) {</span><br><span class="line">        <span class="keyword">if</span> (pattern.charAt(i) == pattern.charAt(len)) {</span><br><span class="line">            <span class="comment">// 找到更长公共子序列</span></span><br><span class="line">            len++;</span><br><span class="line">            lps[i] = len;</span><br><span class="line">            i++;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (len != <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">// 回溯查找更短公共子序列   len = lps[len--];</span></span><br><span class="line">                len = lps[len - <span class="number">1</span>];</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 已回溯至起始点仍未发现公共子序列</span></span><br><span class="line">                lps[i] = <span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> lps;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-b1feeddd5c70cd6e39736ef7184577b7_1440w.png" alt="img"></p>
<ol>
<li>字符串 <code>ACABACA</code> 的最长前缀后缀子串是 3 </li>
<li>字符串增加 <code>C</code> 后字符变成 <code>ACABACAC</code>，此时重新计算字符串的 <code>lps</code> 值</li>
<li>由于字符 B 和字符 C 不相等，此时需要寻找更短的一个子串长度 <code>leng=lps[leng-1]</code> </li>
<li>重复步骤 3，此时字符 <code>C</code> 与新添加的字符 <code>C</code> 相等，寻找出一个更长子串，于是 <code>leng ++</code></li>
</ol>
<h3 id="利用部分匹配表进行匹配"><a href="#利用部分匹配表进行匹配" class="headerlink" title="利用部分匹配表进行匹配"></a>利用部分匹配表进行匹配</h3><p>当在文本字符串中进行匹配时，如果遇到不匹配的字符，我们可以查看部分匹配表来决定下一步的操作。表中的值告诉我们子字符串中有多大长度的字符已经是自匹配的，因此我们可以将子字符串向右移动这么多位，跳过这些已匹配的部分，直接从后续的字符开始比较。</p>
<h3 id="Kmp算法解决的问题"><a href="#Kmp算法解决的问题" class="headerlink" title="Kmp算法解决的问题"></a>Kmp 算法解决的问题</h3><ol>
<li><strong>减少不必要的比较</strong>：在传统的暴力搜索算法中，每次模式字符串与主字符串中的某个子串不匹配时，搜索都会从主字符串的下一个字符重新开始，并重新检查模式字符串。这意味着许多比较实际上是在重复进行。KMP 算法通过预先分析模式字符串并构建一个部分匹配表（LPS 数组），在发生不匹配时，能够跳过那些已经知道不会匹配的部分，从而避免了这些不必要的比较。</li>
<li><strong>提高搜索效率</strong>：通过使用部分匹配表，KMP 算法在遇到不匹配的情况时，可以将模式字符串向前滑动多于一位的距离，而不是仅仅滑动一位。这样，算法可以更快地跳过那些不可能匹配的部分，从而在整体上提高搜索的效率。</li>
<li><strong>最坏情况下的性能保证</strong>：与暴力搜索算法相比，其性能严重依赖于模式字符串和主字符串的特定序列，在最坏的情况下可能需要进行 O (N*M) 次比较（N 是主字符串的长度，M 是模式字符串的长度），KMP 算法保证了在所有情况下的性能，最坏情况下的时间复杂度为 O (N)，这使得 KMP 算法在处理长字符串和复杂模式匹配时尤为有效。</li>
<li><strong>通用性和可靠性</strong>：KMP 算法不依赖于特定的字符集，它可以在任何类型的字符串数据上工作，包括二进制数据。因此，KMP 算法在各种应用中都非常可靠和通用，从文本处理到数据挖掘和生物信息学等领域。</li>
</ol>
<h3 id="预处理模式字符串："><a href="#预处理模式字符串：" class="headerlink" title="预处理模式字符串："></a><strong>预处理模式字符串</strong>：</h3><p>计算一个 LPS 数组，该数组表示在模式字符串中，每个子串的最长相同前缀和后缀的长度。这个信息用于在发生不匹配时，决定如何移动模式字符串以利用之前的匹配信息，而不是从头开始。</p>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-1226b74d7e553cad76f63f9985821372_1440w.png" alt="图2:LPS数组"></p>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-d4500e786483b51a8d207ab561ccab8d_1440w-20240202204734029.png" alt="图3"></p>
<p><strong>在暴力搜索情况下，当出现不匹配时，只能移动一位，然后再次比较，如图 4：</strong></p>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-7c1f8cf2f26f59458d6db7aa538f1506_1440w-20240202204743168.png" alt="图4"></p>
<p><strong>在 KMP 算法中，当出现不匹配时，j=lps [j-1] ，如图 5</strong></p>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-5d90e6ac6fe96b2823ef70cde466628c_1440w.png" alt="图5"></p>
<h3 id="搜索过程："><a href="#搜索过程：" class="headerlink" title="搜索过程："></a><strong>搜索过程</strong>：</h3><p>使用 LPS 数组执行搜索。当在主字符串中遇到不匹配时，LPS 数组指示模式字符串下一步应该移动的位置，从而跳过了已经知道不会匹配的部分。</p>
<h3 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java 实现</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">kmpSearch</span><span class="params">(String text, String pattern)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] lpsArray = computeLPSArray(pattern);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// index for text</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// index for pattern</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; text.length()) {</span><br><span class="line">        <span class="keyword">if</span> (pattern.charAt(j) == text.charAt(i)) {</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (j == pattern.length()) {</span><br><span class="line">            System.out.println(<span class="string">"Pattern found at index: "</span> + (i - j));</span><br><span class="line">            j = lpsArray[j - <span class="number">1</span>];</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; text.length() &amp;&amp; pattern.charAt(j) != text.charAt(i)) {</span><br><span class="line">            <span class="keyword">if</span> (j != <span class="number">0</span>)</span><br><span class="line">                j = lpsArray[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                i++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><ul>
<li>KMPSearch 方法是搜索算法的主体，它接受模式字符串 pat 和主字符串 txt 作为输入，并输出模式字符串在主字符串中出现的所有位置。</li>
<li>computeLPSArray 方法用于计算给定模式字符串的 LPS 数组。LPS 数组对于每个子串 pat [0…i] 保存了在 pat [0…i] 中的最长相等前缀和后缀的长度。</li>
<li>在 KMPSearch 中，通过比较 txt 和 pat 来进行搜索，当遇到不匹配时，使用 lps 数组来决定下一步的搜索位置，这样可以避免从模式字符串的起始位置重新开始搜索，从而提高搜索效率。</li>
</ul>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>KMP 算法的时间复杂度为 O (N)，其中 N 是主字符串的长度，这比朴素的字符串搜索算法，时间复杂度为 O (NM)，M 是模式字符串的长度要高效得多。</p>
<h2 id="github项目"><a href="#github项目" class="headerlink" title="github项目"></a><a href="https://github.com/nadav-cheung/algorithm">github 项目</a></h2>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>字符串搜索算法</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>字符串搜索算法</tag>
        <tag>KMP算法</tag>
      </tags>
  </entry>
  <entry>
    <title>《如何写 LeetCode 刷题笔记》</title>
    <url>/posts/32e49274/</url>
    <content><![CDATA[<h2 id="《如何写LeetCode刷题笔记》"><a href="#《如何写LeetCode刷题笔记》" class="headerlink" title="《如何写LeetCode刷题笔记》"></a>《如何写 LeetCode 刷题笔记》</h2><p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-7b17d478ef4a166be6b8306f9984460c_1440w.png" alt="如何写关于LeetCode专题的理论指导"></p>
<h2 id="选择题目"><a href="#选择题目" class="headerlink" title="选择题目"></a><strong>选择题目</strong></h2><h4 id="1-多样化度级别"><a href="#1-多样化度级别" class="headerlink" title="1. 多样化度级别"></a>1. <strong>多样化度级别</strong></h4><ul>
<li><strong>初级</strong>：从简单的题目开始，帮助初学者建立信心。这些题目通常涉及基本的数据结构和算法。</li>
<li><strong>中级</strong>：包括中等难度的题目，这些题目通常需要更复杂的算法和数据结构，如动态规划、树、图等。</li>
<li><strong>高级</strong>：为更有经验的读者提供高难度题目。这些题目可能需要高级算法技巧和深入的问题分析。</li>
</ul>
<span id="more"></span>

<h4 id="2-按主题或数据结构分类"><a href="#2-按主题或数据结构分类" class="headerlink" title="2. 按主题或数据结构分类"></a>2. <strong>按主题或数据结构分类</strong></h4><ul>
<li>按数据结构分类（例如，数组、链表、树、图、堆）。</li>
<li>按算法类型分类（例如，排序、搜索、动态规划、回溯算法）。</li>
<li>特定主题，如字符串处理、数学问题、设计问题等。</li>
</ul>
<h4 id="3-考虑时效性和流行度"><a href="#3-考虑时效性和流行度" class="headerlink" title="3. 考虑时效性和流行度"></a>3. <strong>考虑时效性和流行度</strong></h4><ul>
<li>选择当前在编程社区中讨论度高的题目，可以吸引更多读者。</li>
<li>考虑时效性题目，如最近在 LeetCode 竞赛中出现的题目。</li>
</ul>
<h4 id="4-综合考虑读者群体"><a href="#4-综合考虑读者群体" class="headerlink" title="4. 综合考虑读者群体"></a>4. <strong>综合考虑读者群体</strong></h4><ul>
<li>如果你的目标读者是寻求工作的求职者，可以专注于经常出现在编程面试中的题目。</li>
<li>如果你的目标是帮助人们提高编程技能，可以选择更具挑战性的题目。</li>
</ul>
<h4 id="5-引入实际应用场景"><a href="#5-引入实际应用场景" class="headerlink" title="5. 引入实际应用场景"></a>5. <strong>引入实际应用场景</strong></h4><ul>
<li>选择那些可以直接应用于实际工作或项目中的题目。</li>
<li>提供实际场景中这些问题的应用示例。</li>
</ul>
<h4 id="6-持续更新和调整"><a href="#6-持续更新和调整" class="headerlink" title="6. 持续更新和调整"></a>6. <strong>持续更新和调整</strong></h4><ul>
<li>定期检查 LeetCode 上的趋势和热门题目。</li>
<li>根据读者的反馈和需求调整题目选择。</li>
</ul>
<h4 id="7-教育价值"><a href="#7-教育价值" class="headerlink" title="7. 教育价值"></a>7. <strong>教育价值</strong></h4><ul>
<li>选择那些能够很好地展示特定编程概念或算法原理的题目。</li>
<li>避免过于简单或过于复杂的题目，以保持教育内容的质量和深度。</li>
</ul>
<h4 id="8-个人兴趣和专长"><a href="#8-个人兴趣和专长" class="headerlink" title="8. 个人兴趣和专长"></a>8. <strong>个人兴趣和专长</strong></h4><ul>
<li>选择你个人感兴趣的题目，这样你更有可能提供深入和热情的解释。</li>
<li>利用你的专长领域，如果你在某个特定的算法或数据结构方面有深厚的理解，考虑围绕这些主题构建内容。</li>
</ul>
<h2 id="详细的解题思路"><a href="#详细的解题思路" class="headerlink" title="详细的解题思路"></a><strong>详细的解题思路</strong></h2><h4 id="1-问题理解"><a href="#1-问题理解" class="headerlink" title="1. 问题理解"></a>1. <strong>问题理解</strong></h4><ul>
<li><strong>概述问题</strong>：简洁地描述问题是什么，它在寻求什么样的解决方案。</li>
<li><strong>关键点识别</strong>：指出问题的关键要素，例如特定的约束条件、预期输出等。</li>
</ul>
<h4 id="2-初始思路"><a href="#2-初始思路" class="headerlink" title="2. 初始思路"></a>2. <strong>初始思路</strong></h4><ul>
<li><strong>直觉分析</strong>：分享你最初阅读题目时的直觉想法，即使这些想法后来被证明是不完整或不准确的。</li>
<li><strong>简单案例分析</strong>：用一些简单的例子来说明问题，并尝试手动解决它们。</li>
</ul>
<h4 id="3-逐步解题过程"><a href="#3-逐步解题过程" class="headerlink" title="3. 逐步解题过程"></a>3. <strong>逐步解题过程</strong></h4><ul>
<li><strong>逐步分析</strong>：逐步解释如何接近问题，包括你尝试了哪些方法和为什么。</li>
<li><strong>不同解决方案的探索</strong>：如果适用，提供不止一种解决方案，并解释每种方法的优缺点。</li>
</ul>
<h4 id="4-算法选择和实现"><a href="#4-算法选择和实现" class="headerlink" title="4. 算法选择和实现"></a>4. <strong>算法选择和实现</strong></h4><ul>
<li><strong>算法决策</strong>：解释为什么选择特定的算法或数据结构。比如，为什么选择动态规划而不是贪心算法。</li>
<li><strong>代码实现</strong>：提供清晰、注释详尽的代码实现。</li>
</ul>
<h4 id="5-复杂度分析"><a href="#5-复杂度分析" class="headerlink" title="5. 复杂度分析"></a>5. <strong>复杂度分析</strong></h4><ul>
<li><strong>时间复杂度</strong>：分析解决方案的时间效率，解释为什么它是这样的。</li>
<li><strong>空间复杂度</strong>：分析解决方案的空间消耗。</li>
</ul>
<h4 id="6-测试和验证"><a href="#6-测试和验证" class="headerlink" title="6. 测试和验证"></a>6. <strong>测试和验证</strong></h4><ul>
<li><strong>测试案例</strong>：提供测试用例，包括边缘案例，来验证解决方案的正确性。</li>
<li><strong>问题和解决方案的验证</strong>：如果有的话，提供 LeetCode 的运行结果或其他形式的验证。</li>
</ul>
<h4 id="7-优化和改进"><a href="#7-优化和改进" class="headerlink" title="7. 优化和改进"></a>7. <strong>优化和改进</strong></h4><ul>
<li><strong>改进可能性</strong>：如果初始解决方案不是最优的，讨论如何进一步优化。</li>
<li><strong>高级技巧和策略</strong>：如果适用，包括高级算法技巧或更复杂的数据结构。</li>
</ul>
<h4 id="8-学习和教育的角度"><a href="#8-学习和教育的角度" class="headerlink" title="8. 学习和教育的角度"></a>8. <strong>学习和教育的角度</strong></h4><ul>
<li><strong>教育意义</strong>：解释这个问题和解决方案对于理解更广泛的编程概念或算法原理的重要性。</li>
<li><strong>延伸阅读</strong>：提供进一步学习资源，如相关算法的深入教程或书籍推荐。</li>
</ul>
<h4 id="9-互动和反馈"><a href="#9-互动和反馈" class="headerlink" title="9. 互动和反馈"></a>9. <strong>互动和反馈</strong></h4><ul>
<li><strong>鼓励反馈</strong>：鼓励读者提问，分享他们自己的解决方案或对你的解决方案提出看法。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h2><p>代码实现是向读者展示如何将解题思路转化为实际代码的关键部分。一个好的代码实现应该清晰、易于理解，并尽可能优化。</p>
<h4 id="1-语言选择"><a href="#1-语言选择" class="headerlink" title="1. 语言选择"></a>1. <strong>语言选择</strong></h4><ul>
<li>选择常见的编程语言，如 Python、Java 或 C++，因为这些语言通常更易于理解且广泛使用。</li>
<li>考虑提供多种语言的实现，以满足不同背景的读者。</li>
</ul>
<h4 id="2-清晰和简洁"><a href="#2-清晰和简洁" class="headerlink" title="2. 清晰和简洁"></a>2. <strong>清晰和简洁</strong></h4><ul>
<li>代码应该易于阅读和理解。避免不必要的复杂性和过度的优化，这可能会使代码难以理解。</li>
<li>使用清晰的变量和函数命名。名称应描述性强，易于理解其用途。</li>
</ul>
<h4 id="3-注释和文档"><a href="#3-注释和文档" class="headerlink" title="3. 注释和文档"></a>3. <strong>注释和文档</strong></h4><ul>
<li>在代码中适当地添加注释，特别是在关键部分，如算法的核心逻辑、复杂的代码块、或特定的技巧。</li>
<li>如果需要，提供函数和类的文档字符串，说明它们的作用、参数和返回值。</li>
</ul>
<h4 id="4-遵循编码标准和最佳实践"><a href="#4-遵循编码标准和最佳实践" class="headerlink" title="4. 遵循编码标准和最佳实践"></a>4. <strong>遵循编码标准和最佳实践</strong></h4><ul>
<li>遵循所选编程语言的编码标准和最佳实践。例如，如果使用 Python，遵循 PEP 8 编码风格。</li>
<li>保持代码格式一致，如缩进、大括号使用等。</li>
</ul>
<h4 id="5-示例输入和输出"><a href="#5-示例输入和输出" class="headerlink" title="5. 示例输入和输出"></a>5. <strong>示例输入和输出</strong></h4><ul>
<li>包含示例输入和对应的输出，以演示如何使用代码。</li>
<li>考虑提供一些测试用例，包括边缘情况，以展示代码的健壮性。</li>
</ul>
<h4 id="6-复杂度分析"><a href="#6-复杂度分析" class="headerlink" title="6. 复杂度分析"></a>6. <strong>复杂度分析</strong></h4><ul>
<li>在代码实现旁边或之后，提供时间复杂度和空间复杂度的分析。</li>
<li>解释特定设计选择如何影响整体复杂度。</li>
</ul>
<h4 id="7-优化和替代方案"><a href="#7-优化和替代方案" class="headerlink" title="7. 优化和替代方案"></a>7. <strong>优化和替代方案</strong></h4><ul>
<li>如果提供了多种解决方案，清楚地区分它们，并解释每种方案的优缺点。</li>
<li>对于初级解决方案，提供可能的优化思路和改进后的代码。</li>
</ul>
<h4 id="8-模块化和可重用性"><a href="#8-模块化和可重用性" class="headerlink" title="8. 模块化和可重用性"></a>8. <strong>模块化和可重用性</strong></h4><ul>
<li>尽可能使代码模块化，这样可以更容易地理解各部分如何协同工作。</li>
<li>考虑代码的可重用性，尤其是对于常见的任务，如排序、搜索等。</li>
</ul>
<h4 id="9-错误处理和边缘情况"><a href="#9-错误处理和边缘情况" class="headerlink" title="9. 错误处理和边缘情况"></a>9. <strong>错误处理和边缘情况</strong></h4><ul>
<li>包括必要的错误处理，确保代码能够优雅地处理异常情况。</li>
<li>明确考虑和处理边缘情况，如空输入、非法值等。</li>
</ul>
<h4 id="10-代码测试和验证"><a href="#10-代码测试和验证" class="headerlink" title="10. 代码测试和验证"></a>10. <strong>代码测试和验证</strong></h4><ul>
<li>验证代码在 LeetCode 上的执行情况，并分享结果，如通过的测试用例数和执行效率。</li>
<li>如果可能，提供单元测试或其他测试方法来进一步验证代码的正确性和健壮性。</li>
</ul>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h2><p>复杂度分析是一个至关重要的部分，因为它帮助读者理解算法的效率和实用性。复杂度分析通常包括时间复杂度和空间复杂度的评估。</p>
<h4 id="1-时间复杂度分析"><a href="#1-时间复杂度分析" class="headerlink" title="1. 时间复杂度分析"></a>1. <strong>时间复杂度分析</strong></h4><ul>
<li><strong>基本概念</strong>：解释时间复杂度的基本概念，即算法执行所需时间与输入大小的关系。</li>
<li><strong>最坏情况分析</strong>：分析算法在最坏情况下的时间复杂度。</li>
<li><strong>平均 / 预期情况分析</strong>：如果适用，分析算法在平均或预期情况下的性能。</li>
<li><strong>算法步骤计算</strong>：详细解释如何根据算法的主要步骤来计算时间复杂度。</li>
<li><strong>循环和递归分析</strong>：对于包含循环或递归的算法，详细说明这些结构如何影响总体时间复杂度。</li>
</ul>
<h4 id="2-空间复杂度分析"><a href="#2-空间复杂度分析" class="headerlink" title="2. 空间复杂度分析"></a>2. <strong>空间复杂度分析</strong></h4><ul>
<li><strong>基本概念</strong>：介绍空间复杂度的基本概念，即算法执行所需的存储空间与输入大小的关系。</li>
<li><strong>内存使用</strong>：分析算法在执行过程中使用的总内存量，包括堆栈、堆和静态存储的使用。</li>
<li><strong>辅助空间</strong>：区分算法本身使用的空间和为存储输入数据而使用的空间。</li>
<li><strong>数据结构的影响</strong>：解释使用的数据结构如何影响空间复杂度。</li>
</ul>
<h4 id="3-实例应用"><a href="#3-实例应用" class="headerlink" title="3. 实例应用"></a>3. <strong>实例应用</strong></h4><ul>
<li><strong>实际代码示例</strong>：提供具体的代码实例，展示如何对该代码进行复杂度分析。</li>
<li><strong>与问题规模的关系</strong>：讨论不同输入规模下算法的复杂度变化。</li>
</ul>
<h4 id="4-优化可能性"><a href="#4-优化可能性" class="headerlink" title="4. 优化可能性"></a>4. <strong>优化可能性</strong></h4><ul>
<li><strong>优化前后的对比</strong>：如果提供了算法的优化版本，比较优化前后的复杂度变化。</li>
<li><strong>讨论优化的必要性</strong>：讨论在实际应用中，是否总是需要最优算法，或者在某些情况下次优解决方案可能更合适。</li>
</ul>
<h4 id="5-图表或视觉辅助"><a href="#5-图表或视觉辅助" class="headerlink" title="5. 图表或视觉辅助"></a>5. <strong>图表或视觉辅助</strong></h4><ul>
<li><strong>图表说明</strong>：如果可能，使用图表或图形来直观展示不同算法的复杂度。</li>
<li><strong>举例说明</strong>：通过具体的输入例子来说明复杂度如何随输入规模变化。</li>
</ul>
<h4 id="6-理论与实践的结合"><a href="#6-理论与实践的结合" class="headerlink" title="6. 理论与实践的结合"></a>6. <strong>理论与实践的结合</strong></h4><ul>
<li><strong>理论分析</strong>：提供理论上的复杂度分析。</li>
<li><strong>实际性能</strong>：如果可能，提供实际运行时的性能数据，以证实理论分析。</li>
</ul>
<h4 id="7-易错点和常见误区"><a href="#7-易错点和常见误区" class="headerlink" title="7. 易错点和常见误区"></a>7. <strong>易错点和常见误区</strong></h4><ul>
<li><strong>指出常见误区</strong>：如误解常数因子的重要性，或者对于特定类型问题的复杂度误判。</li>
<li><strong>错误分析示例</strong>：提供错误分析的例子，帮助读者理解如何避免常见错误。</li>
</ul>
<h4 id="8-扩展阅读"><a href="#8-扩展阅读" class="headerlink" title="8. 扩展阅读"></a>8. <strong>扩展阅读</strong></h4><ul>
<li><strong>深入资源</strong>：推荐关于算法复杂度分析的深入学习资源，如高级教程或书籍。</li>
</ul>
<h2 id="附加资源"><a href="#附加资源" class="headerlink" title="附加资源"></a><strong>附加资源</strong></h2><p>提供附加资源是一个极好的方式，以进一步辅助读者的学习和深入理解。这些资源可以帮助读者拓宽知识面，加深对算法和数据结构的理解。</p>
<h4 id="1-相关算法和数据结构的教程"><a href="#1-相关算法和数据结构的教程" class="headerlink" title="1. 相关算法和数据结构的教程"></a>1. <strong>相关算法和数据结构的教程</strong></h4><ul>
<li>提供针对解决方案中用到的算法和数据结构的深入教程链接。</li>
<li>为初学者和进阶读者提供不同级别的教程。</li>
</ul>
<h4 id="2-书籍推荐"><a href="#2-书籍推荐" class="headerlink" title="2. 书籍推荐"></a>2. <strong>书籍推荐</strong></h4><ul>
<li>推荐一些经典的编程和算法相关书籍，这些书籍对理解基础和高级概念都非常有帮助。</li>
<li>包括适合初学者的入门书籍，以及为有经验的程序员准备的更高级的材料。</li>
</ul>
<h4 id="3-在线课程和视频"><a href="#3-在线课程和视频" class="headerlink" title="3. 在线课程和视频"></a>3. <strong>在线课程和视频</strong></h4><ul>
<li>推荐一些高质量的在线课程或视频教程，特别是那些由知名教育机构或业界专家提供的。</li>
<li>包括免费和付费资源，满足不同读者的需求。</li>
</ul>
<h4 id="4-官方文档和规范"><a href="#4-官方文档和规范" class="headerlink" title="4. 官方文档和规范"></a>4. <strong>官方文档和规范</strong></h4><ul>
<li>提供指向编程语言官方文档的链接，尤其是当你的代码示例使用了某些特定的语言特性时。</li>
<li>对于使用特定技术或框架的解决方案，包括相关的官方文档链接。</li>
</ul>
<h4 id="5-在线编程平台和练习"><a href="#5-在线编程平台和练习" class="headerlink" title="5. 在线编程平台和练习"></a>5. <strong>在线编程平台和练习</strong></h4><ul>
<li>推荐其他类似于 LeetCode 的在线编程平台，以便读者可以在多种环境下练习和测试自己的技能。</li>
<li>包括那些提供不同类型问题和挑战的平台。</li>
</ul>
<h4 id="6-社区和论坛"><a href="#6-社区和论坛" class="headerlink" title="6. 社区和论坛"></a>6. <strong>社区和论坛</strong></h4><ul>
<li>推荐一些活跃的编程和算法相关社区或论坛，如 Stack Overflow、Reddit 的编程子版块等。</li>
<li>这些社区是解决编程问题和与其他开发者交流的好地方。</li>
</ul>
<h4 id="7-案例研究和实际应用"><a href="#7-案例研究和实际应用" class="headerlink" title="7. 案例研究和实际应用"></a>7. <strong>案例研究和实际应用</strong></h4><ul>
<li>提供一些实际案例研究或成功故事，展示算法在实际问题中的应用。</li>
<li>这可以帮助读者理解理论知识如何转化为实际解决方案。</li>
</ul>
<h4 id="8-工具和库"><a href="#8-工具和库" class="headerlink" title="8. 工具和库"></a>8. <strong>工具和库</strong></h4><ul>
<li>推荐一些有用的编程工具和库，这些工具和库可以帮助简化编程任务或提高效率。</li>
<li>包括代码编辑器、调试工具、性能分析工具等。</li>
</ul>
<h4 id="9-个人经验和建议"><a href="#9-个人经验和建议" class="headerlink" title="9. 个人经验和建议"></a>9. <strong>个人经验和建议</strong></h4><ul>
<li>分享你在学习和应用算法过程中的个人经验、技巧和建议。</li>
<li>这些个人洞见可以为读者提供独特的视角和实用的建议。</li>
</ul>
<h4 id="10-面试准备资源"><a href="#10-面试准备资源" class="headerlink" title="10. 面试准备资源"></a>10. <strong>面试准备资源</strong></h4><ul>
<li>如果你的专栏面向求职者，提供有关技术面试准备的资源，如面试技巧、常见问题列表等。</li>
</ul>
<h2 id="互动元素"><a href="#互动元素" class="headerlink" title="互动元素"></a><strong>互动元素</strong></h2><p>加入互动元素可以显著提升读者的参与度和学习体验。互动元素不仅鼓励读者积极参与，而且还促进了知识的交流和社区的建设。</p>
<h4 id="1-评论和讨论区"><a href="#1-评论和讨论区" class="headerlink" title="1. 评论和讨论区"></a>1. <strong>评论和讨论区</strong></h4><ul>
<li>鼓励读者在每篇文章下留言评论，分享他们自己的见解、疑问或不同的解题方法。</li>
<li>回应评论，这不仅表明你重视他们的反馈，也有助于建立社区感。</li>
</ul>
<h4 id="2-问题和挑战"><a href="#2-问题和挑战" class="headerlink" title="2. 问题和挑战"></a>2. <strong>问题和挑战</strong></h4><ul>
<li>在文章末尾提出相关的问题或小挑战，鼓励读者应用他们所学的知识。</li>
<li>这些问题可以是对文章内容的延伸，或是对解题方法的变体。</li>
</ul>
<h4 id="3-投票和调查"><a href="#3-投票和调查" class="headerlink" title="3. 投票和调查"></a>3. <strong>投票和调查</strong></h4><ul>
<li>定期进行关于读者感兴趣的主题或下一篇文章内容的投票和调查。</li>
<li>这可以帮助你了解读者的兴趣点，并根据他们的偏好调整内容。</li>
</ul>
<h4 id="4-代码分享和审查"><a href="#4-代码分享和审查" class="headerlink" title="4. 代码分享和审查"></a>4. <strong>代码分享和审查</strong></h4><ul>
<li>鼓励读者分享他们自己的解题代码，并开放给其他读者进行审查和建议。</li>
<li>这不仅有助于提升编码技能，还能增强社区间的交流和学习。</li>
</ul>
<h4 id="5-交互式学习元素"><a href="#5-交互式学习元素" class="headerlink" title="5. 交互式学习元素"></a>5. <strong>交互式学习元素</strong></h4><ul>
<li>如果可能，加入一些交互式的元素，如在线编程练习或小测验，以测试读者的理解。</li>
<li>这些互动性元素可以使学习过程更有趣味性和参与感。</li>
</ul>
<h4 id="6-直播或视频教程"><a href="#6-直播或视频教程" class="headerlink" title="6. 直播或视频教程"></a>6. <strong>直播或视频教程</strong></h4><ul>
<li>定期举办直播会议或制作视频教程，解答常见问题或深入探讨某个复杂主题。</li>
<li>这为读者提供了实时互动的机会，使他们能够直接从专家那里获得反馈。</li>
</ul>
<h4 id="7-社交媒体互动"><a href="#7-社交媒体互动" class="headerlink" title="7. 社交媒体互动"></a>7. <strong>社交媒体互动</strong></h4><ul>
<li>利用社交媒体平台进行互动，如建立 QQ 群组或 QQ 频道等话题标签。</li>
<li>这可以帮助建立更广泛的社区，并提供另一个互动和讨论的渠道。</li>
</ul>
<h4 id="8-定期反馈征集"><a href="#8-定期反馈征集" class="headerlink" title="8. 定期反馈征集"></a>8. <strong>定期反馈征集</strong></h4><ul>
<li>定期征集读者对专栏内容和格式的反馈，了解他们的喜好和改进意见。</li>
<li>这不仅可以提升内容质量，也能让读者感到他们的意见被重视。</li>
</ul>
<h4 id="9-案例研究和实例分析"><a href="#9-案例研究和实例分析" class="headerlink" title="9. 案例研究和实例分析"></a>9. <strong>案例研究和实例分析</strong></h4><ul>
<li>提出现实世界的案例研究或具体问题实例，并邀请读者提供解决方案或分析。</li>
<li>这种方法有助于将理论知识应用于实际情境。</li>
</ul>
<h4 id="10-读者贡献和合作"><a href="#10-读者贡献和合作" class="headerlink" title="10. 读者贡献和合作"></a>10. <strong>读者贡献和合作</strong></h4><ul>
<li>鼓励读者贡献他们自己的相关文章或教程，并在专栏中予以展示。</li>
<li>这不仅提升了社区的参与感，还能让读者之间相互学习。</li>
</ul>
<h2 id="定期更新"><a href="#定期更新" class="headerlink" title="定期更新"></a><strong>定期更新</strong></h2><p>定期更新是保持读者参与度和专栏活力的关键。应该确保内容既丰富又有价值。</p>
<h4 id="1-新题目解析"><a href="#1-新题目解析" class="headerlink" title="1. 新题目解析"></a>1. <strong>新题目解析</strong></h4><ul>
<li>每次更新时，引入一个或多个新的 LeetCode 题目。</li>
<li>提供这些题目的详细解题思路、代码实现、以及复杂度分析。</li>
</ul>
<h4 id="2-技术专题"><a href="#2-技术专题" class="headerlink" title="2. 技术专题"></a>2. <strong>技术专题</strong></h4><ul>
<li>定期专注于特定的算法或数据结构主题，如动态规划、图算法、树结构等。</li>
<li>提供这些技术专题的深入讲解和与之相关的题目解析。</li>
</ul>
<h4 id="3-读者互动反馈"><a href="#3-读者互动反馈" class="headerlink" title="3. 读者互动反馈"></a>3. <strong>读者互动反馈</strong></h4><ul>
<li>包含来自读者的问题、评论或代码分享，并在更新中对这些进行回应或展示。</li>
<li>通过读者的反馈来指导未来的内容方向和改进。</li>
</ul>
<h4 id="4-编程技巧和策略"><a href="#4-编程技巧和策略" class="headerlink" title="4. 编程技巧和策略"></a>4. <strong>编程技巧和策略</strong></h4><ul>
<li>分享有关编程的一般技巧、最佳实践和常见误区。</li>
<li>提供如何有效地解决编程问题的策略和建议。</li>
</ul>
<h4 id="5-案例研究和实际应用"><a href="#5-案例研究和实际应用" class="headerlink" title="5. 案例研究和实际应用"></a>5. <strong>案例研究和实际应用</strong></h4><ul>
<li>呈现算法在现实世界中的应用案例研究，展示理论与实践的结合。</li>
<li>探讨特定算法如何解决实际问题。</li>
</ul>
<h4 id="6-算法和数据结构基础"><a href="#6-算法和数据结构基础" class="headerlink" title="6. 算法和数据结构基础"></a>6. <strong>算法和数据结构基础</strong></h4><ul>
<li>对于那些新入门的读者，定期回顾算法和数据结构的基础知识。</li>
<li>提供基础概念的清晰解释和示例。</li>
</ul>
<h4 id="7-行业趋势和新闻"><a href="#7-行业趋势和新闻" class="headerlink" title="7. 行业趋势和新闻"></a>7. <strong>行业趋势和新闻</strong></h4><ul>
<li>包括关于编程、技术发展或 IT 行业的最新趋势和新闻。</li>
<li>探讨这些趋势如何影响编程实践和技术面试。</li>
</ul>
<h4 id="8-面试准备和技巧"><a href="#8-面试准备和技巧" class="headerlink" title="8. 面试准备和技巧"></a>8. <strong>面试准备和技巧</strong></h4><ul>
<li>提供技术面试的准备建议，包括常见的面试问题和答题策略。</li>
<li>分享成功的面试经验和故事。</li>
</ul>
<h4 id="9-资源分享"><a href="#9-资源分享" class="headerlink" title="9. 资源分享"></a>9. <strong>资源分享</strong></h4><ul>
<li>分享有用的资源，如书籍、在线课程、工具和库等。</li>
<li>提供用于学习和提高编程技能的额外材料。</li>
</ul>
<h4 id="10-用户互动和挑战"><a href="#10-用户互动和挑战" class="headerlink" title="10. 用户互动和挑战"></a>10. <strong>用户互动和挑战</strong></h4><ul>
<li>发起编程挑战或小竞赛，激励读者参与并应用他们的技能。 </li>
<li>鼓励读者分享他们的解决方案和学习心得。</li>
</ul>
<h4 id="11-回顾和总结"><a href="#11-回顾和总结" class="headerlink" title="11. 回顾和总结"></a>11. <strong>回顾和总结</strong></h4><ul>
<li>定期回顾过去的文章和讨论的主题，为新读者提供内容摘要。 </li>
<li>总结关键概念和学习点。</li>
</ul>
<h4 id="12-个人经验和洞见"><a href="#12-个人经验和洞见" class="headerlink" title="12. 个人经验和洞见"></a>12. <strong>个人经验和洞见</strong></h4><ul>
<li>分享你在编程和算法领域的个人经验、挑战和成长。 </li>
<li>提供个人见解和建议，以助于读者的职业发展。</li>
<li>确保定期更新不仅包含新的内容和知识点，还要维护与读者的互动和参与。通过综合这些元素，能够持续吸引并教育你的读者，同时保持内容的新鲜感和相关性。</li>
</ul>
<h2 id="适合初学者和高级读者"><a href="#适合初学者和高级读者" class="headerlink" title="适合初学者和高级读者"></a><strong>适合初学者和高级读者</strong></h2><p>同时适合初学者和高级读者，需要在内容的深度和广度上进行平衡。应该提供从基础知识到高级技巧的全方位覆盖，同时确保内容既易于理解又具有挑战性。</p>
<h4 id="1-分层次的难度设置"><a href="#1-分层次的难度设置" class="headerlink" title="1. 分层次的难度设置"></a>1. <strong>分层次的难度设置</strong></h4><ul>
<li>明确标记每个题目的难度级别（例如，“初级”，“中级”，“高级”），这样读者可以根据自己的水平选择合适的内容。</li>
<li>提供不同难度级别的题目，从基础算法和数据结构到更高级和复杂的问题。</li>
</ul>
<h4 id="2-基础知识和概念解释"><a href="#2-基础知识和概念解释" class="headerlink" title="2. 基础知识和概念解释"></a>2. <strong>基础知识和概念解释</strong></h4><ul>
<li>对于初学者，提供基础算法和数据结构的详细解释，帮助他们建立坚实的基础。</li>
<li>包括基本的编程概念、算法原理和数据结构的介绍。</li>
</ul>
<h4 id="3-逐步引导的解题过程"><a href="#3-逐步引导的解题过程" class="headerlink" title="3. 逐步引导的解题过程"></a>3. <strong>逐步引导的解题过程</strong></h4><ul>
<li>对于每个问题，提供逐步的解题指导，包括详细的算法步骤和思路分析。</li>
<li>这对初学者特别有用，他们可以通过这种方式学习如何逐步解决问题。</li>
</ul>
<h4 id="4-代码实现和注释"><a href="#4-代码实现和注释" class="headerlink" title="4. 代码实现和注释"></a>4. <strong>代码实现和注释</strong></h4><ul>
<li>提供清晰的代码实现，并在代码中添加充分的注释，解释关键步骤和逻辑。</li>
<li>适当使用伪代码和流程图，以帮助初学者更好地理解算法流程。</li>
</ul>
<h4 id="5-复杂度分析-1"><a href="#5-复杂度分析-1" class="headerlink" title="5. 复杂度分析"></a>5. <strong>复杂度分析</strong></h4><ul>
<li>提供每种解决方案的时间和空间复杂度分析。</li>
<li>这不仅有助于初学者理解算法效率的重要性，也满足高级读者对深入理解的需求。</li>
</ul>
<h4 id="6-高级主题和技巧"><a href="#6-高级主题和技巧" class="headerlink" title="6. 高级主题和技巧"></a>6. <strong>高级主题和技巧</strong></h4><ul>
<li>包括高级算法技巧、优化策略和复杂数据结构的讨论，以吸引更有经验的读者。</li>
<li>这些内容可以作为专栏的进阶部分，挑战和启发高级读者。</li>
</ul>
<h2 id="可视化和示例"><a href="#可视化和示例" class="headerlink" title="可视化和示例"></a><strong>可视化和示例</strong></h2><p>有效地使用可视化和示例是提升教学效果和增强读者理解的关键。这些工具能够帮助说明复杂的概念，使问题和解决方案更加直观和易于理解。</p>
<h4 id="1-算法流程图"><a href="#1-算法流程图" class="headerlink" title="1. 算法流程图"></a>1. <strong>算法流程图</strong></h4><ul>
<li>使用流程图来描述算法的步骤和决策过程。</li>
<li>这对于说明复杂的逻辑或决策树特别有用。</li>
</ul>
<h4 id="2-数据结构图解"><a href="#2-数据结构图解" class="headerlink" title="2. 数据结构图解"></a>2. <strong>数据结构图解</strong></h4><ul>
<li>对于数据结构（如链表、树、图等）的操作，提供图解可以帮助读者更好地理解其结构和工作方式。</li>
<li>例如，在解释二叉树问题时，使用树的图形表示可以大大提升理解度。</li>
</ul>
<h4 id="3-示例代码与注释"><a href="#3-示例代码与注释" class="headerlink" title="3. 示例代码与注释"></a>3. <strong>示例代码与注释</strong></h4><ul>
<li>提供清晰、注释详尽的示例代码，展示如何实现特定算法或解决特定问题。</li>
<li>代码示例应该简洁明了，避免不必要的复杂性。</li>
</ul>
<h4 id="4-步骤演示"><a href="#4-步骤演示" class="headerlink" title="4. 步骤演示"></a>4. <strong>步骤演示</strong></h4><ul>
<li>通过逐步演示解决问题的过程，可以帮助读者理解每一步的目的和方法。</li>
<li>可以使用动画或静态图像序列来展示算法的每个步骤。</li>
</ul>
<h4 id="5-比较不同解决方案"><a href="#5-比较不同解决方案" class="headerlink" title="5. 比较不同解决方案"></a>5. <strong>比较不同解决方案</strong></h4><ul>
<li>当提供多种解决方案时，可视化对比这些方案的效率和效果。</li>
<li>例如，使用图表展示不同算法的时间复杂度和空间复杂度。</li>
</ul>
<h4 id="6-实际案例的应用"><a href="#6-实际案例的应用" class="headerlink" title="6. 实际案例的应用"></a>6. <strong>实际案例的应用</strong></h4><ul>
<li>提供实际问题的案例，并展示如何应用特定的算法或数据结构来解决这些问题。</li>
<li>这可以包括现实世界的数据和相应的可视化处理。</li>
</ul>
<h4 id="7-交互式工具"><a href="#7-交互式工具" class="headerlink" title="7. 交互式工具"></a>7. <strong>交互式工具</strong></h4><ul>
<li>如果可能，提供或链接到交互式工具，如在线编程环境或可视化工具，以便读者能够实践和实验。</li>
<li>这种工具可以提供即时反馈，增强学习体验。</li>
</ul>
<h4 id="8-错误和常见问题的解释"><a href="#8-错误和常见问题的解释" class="headerlink" title="8. 错误和常见问题的解释"></a>8. <strong>错误和常见问题的解释</strong></h4><ul>
<li>使用可视化手段展示常见的错误和误解，以及如何避免它们。</li>
<li>例如，展示错误实现的结果和正确实现的结果之间的差异。</li>
</ul>
<h4 id="9-辅助材料"><a href="#9-辅助材料" class="headerlink" title="9. 辅助材料"></a>9. <strong>辅助材料</strong></h4><ul>
<li>提供下载或打印的辅助材料，如算法的流程图或数据结构的图解。</li>
<li>这些材料可以作为学习工具，帮助读者在离线时复习和参考。</li>
</ul>
<h4 id="10-故事讲述和场景模拟"><a href="#10-故事讲述和场景模拟" class="headerlink" title="10. 故事讲述和场景模拟"></a>10. <strong>故事讲述和场景模拟</strong></h4><ul>
<li>使用故事讲述或情景模拟的方式来描述问题和解决方案，增加内容的吸引力和可记忆性。 </li>
<li>这种方法可以使抽象的概念更加生动和具体。</li>
</ul>
<p>通过将这些可视化和示例策略整合到你的文章中，可以显著提高内容的可访问性和教育效果，使复杂的概念和解决方案对所有读者都易于理解和掌握。</p>
<h2 id="反馈和迭代"><a href="#反馈和迭代" class="headerlink" title="反馈和迭代"></a><strong>反馈和迭代</strong></h2><p>定期收集反馈并进行迭代更新是至关重要的。这样可以确保内容保持相关性，满足读者的需求，并且持续提升质量。</p>
<h4 id="1-定期收集反馈"><a href="#1-定期收集反馈" class="headerlink" title="1. 定期收集反馈"></a>1. <strong>定期收集反馈</strong></h4><ul>
<li><strong>使用调查和问卷</strong>：定期通过在线调查或问卷收集读者的反馈。问卷可以包括对内容、可理解性、实用性等方面的问题。</li>
<li><strong>评论区反馈</strong>：鼓励读者在文章评论区留下他们的想法和建议。</li>
</ul>
<h4 id="2-社交媒体和社区互动"><a href="#2-社交媒体和社区互动" class="headerlink" title="2. 社交媒体和社区互动"></a>2. <strong>社交媒体和社区互动</strong></h4><ul>
<li><strong>社交媒体平台</strong>：利用社交媒体平台收集反馈，并与读者进行更直接的互动。</li>
<li><strong>在线编程社区</strong>：在如 Reddit、Stack Overflow 等编程社区发布你的内容，并收集那里的反馈。</li>
</ul>
<h4 id="3-定期审查和更新内容"><a href="#3-定期审查和更新内容" class="headerlink" title="3. 定期审查和更新内容"></a>3. <strong>定期审查和更新内容</strong></h4><ul>
<li><strong>更新旧文章</strong>：根据新的信息、技术更新或读者反馈定期更新旧文章。</li>
<li><strong>添加新内容</strong>：基于读者的兴趣和需求添加新的题目和概念。</li>
</ul>
<h4 id="4-跟踪和分析读者数据"><a href="#4-跟踪和分析读者数据" class="headerlink" title="4. 跟踪和分析读者数据"></a>4. <strong>跟踪和分析读者数据</strong></h4><ul>
<li><strong>网站分析</strong>：使用工具如 Google Analytics 来跟踪和分析访问者的行为，了解最受欢迎的文章和读者的阅读偏好。</li>
<li><strong>阅读时长和互动率</strong>：分析文章的阅读时长、评论和分享次数，以评估内容的互动度和吸引力。</li>
</ul>
<h4 id="5-实施读者建议"><a href="#5-实施读者建议" class="headerlink" title="5. 实施读者建议"></a>5. <strong>实施读者建议</strong></h4><ul>
<li><strong>读者建议的采纳</strong>：积极采纳并实施读者的建议，无论是内容、格式还是教学方法上的改进。</li>
<li><strong>透明的改进过程</strong>：公开讨论如何根据反馈改进内容，并向读者展示他们的意见是如何被采纳的。</li>
</ul>
<h4 id="6-测试新格式和方法"><a href="#6-测试新格式和方法" class="headerlink" title="6. 测试新格式和方法"></a>6. <strong>测试新格式和方法</strong></h4><ul>
<li><strong>实验性内容</strong>：尝试不同的内容格式和教学方法，看看哪些更受欢迎或有效。</li>
<li><strong>小规模测试</strong>：在小范围内测试新想法，并基于反馈进行调整。</li>
</ul>
<h4 id="7-透明和开放的沟通"><a href="#7-透明和开放的沟通" class="headerlink" title="7. 透明和开放的沟通"></a>7. <strong>透明和开放的沟通</strong></h4><ul>
<li><strong>公开沟通</strong>：定期与读者沟通你的专栏的更新计划和未来方向。</li>
<li><strong>建立信任</strong>：通过透明和一致的沟通建立信任关系，让读者感到他们的声音被听到和重视。</li>
</ul>
<h4 id="8-长期目标和短期反馈的平衡"><a href="#8-长期目标和短期反馈的平衡" class="headerlink" title="8. 长期目标和短期反馈的平衡"></a>8. <strong>长期目标和短期反馈的平衡</strong></h4><ul>
<li><strong>短期调整</strong>：根据即时反馈进行短期调整。</li>
<li><strong>长期规划</strong>：同时，保持对专栏长期目标和愿景的承诺。</li>
</ul>
<h4 id="9-鼓励多样化的观点"><a href="#9-鼓励多样化的观点" class="headerlink" title="9. 鼓励多样化的观点"></a>9. <strong>鼓励多样化的观点</strong></h4><ul>
<li><strong>多元化反馈</strong>：鼓励不同背景和技能水平的读者提供反馈。</li>
<li><strong>全面视角</strong>：这有助于你获得更全面的视角，并对不同类型的读者都有所帮助。</li>
</ul>
<h4 id="10-定期总结和反思"><a href="#10-定期总结和反思" class="headerlink" title="10. 定期总结和反思"></a>10. <strong>定期总结和反思</strong></h4><ul>
<li><strong>自我评估：</strong>定期进行自我评估，思考专栏的发展方向和个人作为内容创作者的成长。</li>
<li><strong>公开反思：</strong>与读者分享</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode刷题笔记</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>写作</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>《[04] 寻找两个正序数组的中位数》</title>
    <url>/posts/af104c4/</url>
    <content><![CDATA[<h2 id="《LeetCode-04-寻找两个正序数组的中位数》"><a href="#《LeetCode-04-寻找两个正序数组的中位数》" class="headerlink" title="《LeetCode:[04]寻找两个正序数组的中位数》"></a>《LeetCode:[04] 寻找两个正序数组的中位数》</h2><p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-7d5b231dd4e7405966a57996174e9bd8_1440w.png" alt="《LeetCode：[04]寻找两个正序数组的中位数》"></p>
<p><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">力扣（LeetCode）官网 - 寻找两个正序数组的中位数</a></p>
<p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p>
<p>算法的时间复杂度应该为 O (log (m+n)) 。</p>
<span id="more"></span>

<p><strong>示例 1：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">3</span>], nums2 = [<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">2.00000</span></span><br><span class="line">解释：合并数组 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] ，中位数 <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>], nums2 = [<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">2.50000</span></span><br><span class="line">解释：合并数组 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] ，中位数 (<span class="number">2</span> + <span class="number">3</span>) / <span class="number">2</span> = <span class="number">2.5</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>方法签名</strong></p>
<figure class="highlight arduino"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> </span>{  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="解题思路历程"><a href="#解题思路历程" class="headerlink" title="解题思路历程"></a>解题思路历程</h2><p>看完这个问题你想到了什么？若是思路没有问题应该是二分搜索算法，但传统的二分搜索是针对一个已经排序的数组，但这里有两个已经排序的数组，那应该怎么处理呢？</p>
<p><strong>最直观的思路</strong>：将两个已排序的数组合并为一个已经排序的数组，然后使用二分搜索算法搜索结果。</p>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-479beb2c8e5b2b30482dac523ce15386_1440w.png" alt="img"></p>
<p>将两个排序数组合并为一个排序数组</p>
<p>可以非常明显的看出答案是 <code>4</code>，但是两个有序数组合并的时间复杂度 <code>O(m+n)</code>，已经不符合 <code>O(log (m+n))</code> 的要求。</p>
<p>那么如何在不合并的情况下找出这个结果呢？我们找一下规律，其实就是 <code>nums1</code> 数组中有一个 <code>i</code> 将数组 <code>nums1</code> 分成两半， <code>nums2</code> 数组中有一个 j 将数组 <code>nums2</code> 分成两半。数组 nums1 和 nums2 的前一半数量等于两个数组数量和<code>（m+n）</code>的一半，结果向上取整。 数组 <code>nums1</code> 和 <code>nums2</code> 的前一半数据的最大值小于等于后一半数据的最小值。</p>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-512136bf695b5da4bcff6c0faa7f2eb1_1440w-20240116023133363.png" alt="img"></p>
<p>i 和 j 切分后的数组</p>
<p>我们将合并后的数组重新拆开，发现一个规律，只要找到一个合适的 **<code>i</code>** 和 **<code>j</code>** 满足以下情况，如上图。<br>$$<br>i+j=（m+n+1）/2<br>$$</p>
<p>$$<br>nums1[i-1]&lt;=nums2[j]<br>$$</p>
<p>$$<br>nums[j-1]&lt;=nums1[i]<br>$$</p>
<p>最终，这个问题就可以转换成在较小的那个数组上进行二分查找，需要找出一个 **<code>i</code>** 满足如下条件。<br>$$<br>j=（m+n+1）/2 -i<br>$$</p>
<p>$$<br>nums1[i-1]&lt;=nums2[j]<br>$$</p>
<p>$$<br>nums[j-1]&lt;=nums1[i]<br>$$</p>
<h2 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h2><h3 id="理解问题"><a href="#理解问题" class="headerlink" title="理解问题:"></a><strong>理解问题</strong>:</h3><ul>
<li>目标是找到两个已排序数组的中位数。</li>
<li>假设数组 <code>nums1</code> 和 <code>nums2 </code>都不为空，并且它们的总长度是 <code>m+n</code>。</li>
</ul>
<h3 id="检查特殊情况"><a href="#检查特殊情况" class="headerlink" title="检查特殊情况:"></a><strong>检查特殊情况</strong>:</h3><ul>
<li>如果一个数组为空，中位数就是另一个数组的中位数。</li>
<li>如果两个数组的总长度是偶数，中位数是中间两个数的平均值；如果是奇数，则是中间的那个数。</li>
</ul>
<h3 id="二分搜索法"><a href="#二分搜索法" class="headerlink" title="二分搜索法:"></a><strong>二分搜索法</strong>:</h3><ul>
<li><p>使用二分搜索找到合适的切分位置。这意味着在 <code>nums1</code> 和 <code>nums2</code> 中找到两个位置 <code>i</code> 和<code> j</code>，使得<br>$$<br>nums1[i-1]&lt;=nums2[j]<br>$$</p>
<p>$$<br>nums1[i-1]&lt;=nums2[j]<br>$$</p>
</li>
<li><p>这个过程需要不断调整 <code>i </code>和 <code>j</code> 以满足上述条件，同时保证</p>
</li>
</ul>
<p>$$<br>i+j=（m+n+1）/2<br>$$</p>
<h3 id="计算中位数"><a href="#计算中位数" class="headerlink" title="计算中位数:"></a><strong>计算中位数</strong>:</h3><ul>
<li><p>一旦找到合适的 i 和 j，中位数可以通过比较 </p>
</li>
<li><p>nums1 [i-1]、nums1 [i]、nums2 [j-1] 和 nums2 [j] 来确定。</p>
</li>
<li><p>如果总长度是奇数，则中位数是<br>$$<br>max(nums1[i-1],nums2[j-1])<br>$$</p>
</li>
<li><p>如果总长度是偶数，则中位数是</p>
</li>
</ul>
<p>$$<br>(max(nums1[i-1],nums[j-1])+max(nums1[i],nums[j]))/2<br>$$</p>
<h3 id="边界条件处理"><a href="#边界条件处理" class="headerlink" title="边界条件处理:"></a><strong>边界条件处理</strong>:</h3><ul>
<li>在二分搜索过程中，需要考虑数组边界情况。</li>
<li>例如，当<code> i</code> 为 <code>0</code> 或 <code>n </code>时，应该相应地处理<code> nums1[i-1]</code> 或 <code>nums1[i]</code>。</li>
</ul>
<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析:"></a><strong>时间复杂度分析</strong>:</h3><p>此算法的时间复杂度通常是 <code>O(log(min(m, n)))</code>，其中 <code>m</code> 和 <code>n</code> 是两个数组的长度。</p>
<p>实现这个算法时，关键在于理解如何通过二分搜索在两个数组中找到正确的切分点，以及如何处理边界情况。</p>
<h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><p><strong>选择较短的数组进行二分查找：</strong>为了优化性能，总是在两个数组中较短的那个上执行二分查找。</p>
<p><strong>二分查找的应用：</strong>使用二分查找找到一个切分点，这个切分点将两个数组划分为左右两部分，使得左边所有元素都小于右边的所有元素。</p>
<p><strong>确保切分的正确性：</strong>确保左侧部分的最大值小于或等于右侧部分的最小值。</p>
<p><strong>计算中位数：</strong></p>
<ul>
<li>如果两个数组的总长度是偶数，中位数是左侧最大值和右侧最小值的平均数。</li>
<li>如果总长度是奇数，中位数是左侧的最大值。</li>
</ul>
<p><strong>处理边界条件：</strong>考虑数组长度为零或者切分点在数组的起始或结束位置的情况。</p>
<h3 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArray</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> {</span><br><span class="line">    <span class="comment">// 确保 nums1 是较短的数组</span></span><br><span class="line">    <span class="keyword">if</span> (nums1.length &gt; nums2.length) {</span><br><span class="line">        <span class="type">int</span>[] temp = nums1;</span><br><span class="line">        nums1 = nums2;</span><br><span class="line">        nums2 = temp;</span><br><span class="line">        temp = <span class="literal">null</span>;  <span class="comment">// help gc</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> m;</span><br><span class="line">    <span class="type">int</span> <span class="variable">halfLength</span> <span class="operator">=</span> (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nums1[i-1] &lt;= nums2[j]</span></span><br><span class="line">    <span class="comment">// nums2[j-1] &lt;= nums1[i]</span></span><br><span class="line">    <span class="comment">// i + j = (n + 1) / 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">        <span class="comment">// 两个队列的临时变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> halfLength - i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; right &amp;&amp; nums2[j - <span class="number">1</span>] &gt; nums1[i]) {</span><br><span class="line">            left = i + <span class="number">1</span>; <span class="comment">// i is too small</span></span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (i &gt;= left &amp;&amp; nums1[i - <span class="number">1</span>] &gt; nums2[j]) {</span><br><span class="line">            right = i; <span class="comment">// i is too big</span></span><br><span class="line">        } <span class="keyword">else</span> { <span class="comment">// i is perfect</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">maxLeft</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) {</span><br><span class="line">                maxLeft = nums2[j - <span class="number">1</span>];</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) {</span><br><span class="line">                maxLeft = nums1[i - <span class="number">1</span>];</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                maxLeft = Math.max(nums1[i - <span class="number">1</span>], nums2[j - <span class="number">1</span>]);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((m + n) % <span class="number">2</span> == <span class="number">1</span>) {</span><br><span class="line">                <span class="keyword">return</span> maxLeft;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">minRight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == m) {</span><br><span class="line">                minRight = nums2[j];</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (j == n) {</span><br><span class="line">                minRight = nums1[i];</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                minRight = Math.min(nums2[j], nums1[i]);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> (maxLeft + minRight) / <span class="number">2.0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在这个实现中，我们首先确定两个数组中较短的那个，并在其上执行二分查找。</p>
<p>我们不断地调整切分位置，直到找到一个位置，使得左侧所有元素都小于或等于右侧所有元素。然后根据左右两侧元素的最大值和最小值计算出中位数。</p>
<p>这种方法的时间复杂度为 <code>O(log(min(m, n)))</code>，其中 <code>m</code> 和 <code>n</code> 分别是两个数组的长度。</p>
]]></content>
      <categories>
        <category>LeetCode刷题笔记</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>二分查找算法</tag>
      </tags>
  </entry>
  <entry>
    <title>《[02] 两数相加》</title>
    <url>/posts/216d1c97/</url>
    <content><![CDATA[<h2 id="《LeetCode-02-两数相加》"><a href="#《LeetCode-02-两数相加》" class="headerlink" title="《LeetCode:[02]两数相加》"></a>《LeetCode:[02] 两数相加》</h2><p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-f01e20d5cf998483165385f565e865a4_1440w.png" alt="《LeetCode：[02]两数相加》"></p>
<p><a href="https://leetcode.cn/problems/add-two-numbers/description/">力扣（LeetCode）官网 - 两数相加</a></p>
<p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<span id="more"></span>

<p> <strong>示例 1：</strong></p>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-531337b42aa8798d9f828515ce201ffb_1440w-20240115183417120.jpg" alt="img"></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：l1 = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>], l2 = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">7</span>,<span class="number">0</span>,<span class="number">8</span>]</span><br><span class="line">解释：<span class="number">342</span> + <span class="number">465</span> = <span class="number">807</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：l1 = [<span class="number">0</span>], l2 = [<span class="number">0</span>]</span><br><span class="line">输出：[<span class="number">0</span>]</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入：l1 = [<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>], l2 = [<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>]</span><br><span class="line">输出：[<span class="number">8</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure>

<p><strong>方法签名</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> {   </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p>“Add Two Numbers” 是一个中等难度的问题，涉及链表的操作。</p>
<p>这个问题的描述是：你有两个非空的链表，代表两个非负的整数。它们的每个节点都包含一个数字。数字以相反的顺序存储，每个节点包含一个数字。你需要将这两个数相加，并将它们作为一个链表返回。</p>
<p>问题的关键在于处理链表的遍历和进位。下面是使用 Java 实现的一个解决方案</p>
<h2 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h2><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><ol>
<li><strong>创建虚拟头节点</strong>：使用一个虚拟头节点 dummyHead 来简化边界情况的处理，这样每个节点都可以统一处理。</li>
<li><strong>遍历链表</strong>：同时遍历两个链表 l1 和 l2，直到两者都到达尾部。</li>
<li><strong>计算和与进位</strong>：每一步计算两个节点的和，加上前一步的进位（如果有的话）。新的进位是和除以 10 的结果，而新节点的值是和对 10 的余数。</li>
<li><strong>创建新节点</strong>：为每一步的和创建一个新的节点，并将其添加到当前节点的 next。</li>
<li><strong>移动指针</strong>：移动 l1、l2 和 curr 指针。</li>
<li><strong>检查最后的进位</strong>：如果最后还有进位（大于 0），需要创建一个新的节点。</li>
<li><strong>返回结果</strong>：因为 dummyHead 是虚拟头节点，所以返回 dummyHead.next。</li>
</ol>
<p>这个解法的时间复杂度是 O (max (n, m))，其中 n 和 m 分别是两个链表的长度。空间复杂度是 O (max (n, m))，主要用于存储新链表。</p>
<h2 id="Java解决方案"><a href="#Java解决方案" class="headerlink" title="Java解决方案"></a>Java 解决方案</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> {</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() {}</span><br><span class="line">    ListNode(<span class="type">int</span> val) { <span class="built_in">this</span>.val = val; }</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) { <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">        <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> {</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> dummyHead;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span>) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> l1 != <span class="literal">null</span> ? l1.val : <span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> l2 != <span class="literal">null</span> ? l2.val : <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 公式</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> x + y + carry;</span><br><span class="line">                <span class="comment">// 进位</span></span><br><span class="line">                carry = sum / <span class="number">10</span>;</span><br><span class="line">                current.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">                current = current.next;</span><br><span class="line">                <span class="keyword">if</span> (l1 != <span class="literal">null</span>) {</span><br><span class="line">                    l1 = l1.next;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (l2 != <span class="literal">null</span>) {</span><br><span class="line">                    l2 = l2.next;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 额外处理进位</span></span><br><span class="line">            <span class="keyword">if</span> (carry != <span class="number">0</span>) {</span><br><span class="line">                current.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="动画GIF演示"><a href="#动画GIF演示" class="headerlink" title="动画GIF演示"></a>动画 GIF 演示</h2><p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/v2-d530daeba253cc7a5e97d80e9af76399_1440w-20240115184432522.gif" alt="img"></p>
]]></content>
      <categories>
        <category>LeetCode刷题笔记</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>《Binary Search Tree BST 二叉搜索树》</title>
    <url>/posts/59f3686c/</url>
    <content><![CDATA[<h2 id="《算法与数据结构：Binary-Search-Tree-BST二叉搜索树》"><a href="#《算法与数据结构：Binary-Search-Tree-BST二叉搜索树》" class="headerlink" title="《算法与数据结构：Binary Search Tree BST二叉搜索树》"></a>《算法与数据结构：Binary Search Tree BST 二叉搜索树》</h2><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><p>二分搜索树（Binary Search Tree，简称 BST）是一种基于二叉树的数据结构，它在数据存储、检索和管理方面具有独特的优势。每个节点都有一个键（和相应的值）及最多两个子节点。它的关键特性是，对于树中的任意节点 X，其左子树中的所有键都小于 X 的键，而右子树的键都大于 X 的键。这一特性使得二分搜索树在执行查找、插入和删除操作时效率较高，是许多高级数据结构和算法的基础。</p>
<h3 id="定义和特性"><a href="#定义和特性" class="headerlink" title="定义和特性"></a>定义和特性</h3><ul>
<li><strong>定义</strong>：二分搜索树是一个二叉树，其中每个节点都含有一个可比较的键（及与之关联的值），并且对于任何节点，其左子树中的所有键都小于该节点的键，其右子树的所有键都大于该节点的键。</li>
<li><strong>特性</strong>：</li>
<li><strong>有序性</strong>：通过中序遍历二分搜索树，可以获得一个有序的键序列。</li>
<li><strong>动态数据结构</strong>：二分搜索树可以在运行时动态地插入和删除节点，从而适应数据集的变化。</li>
<li><strong>效率</strong>：在平衡的情况下，二叉搜索树的操作（如查找、插入、删除）可以在 O (log n) 时间内完成，其中 n 是树中的节点数。</li>
</ul>
<h3 id="节点结构"><a href="#节点结构" class="headerlink" title="节点结构"></a>节点结构</h3><p>每个节点通常包含以下几个基本组成部分：</p>
<ul>
<li><strong>键（Key）</strong>：节点的唯一标识符，用于节点间的比较。</li>
<li><strong>值（Value）</strong>：与键相关联的数据。</li>
<li><strong>左子节点（Left Child）</strong>：指向左侧子节点的指针，该子节点的键小于当前节点。</li>
<li><strong>右子节点（Right Child）</strong>：指向右侧子节点的指针，该子节点的键大于当前节点。</li>
</ul>
<p>二叉搜索树是一种特殊的二叉树，它满足以下条件：</p>
<ol>
<li><strong>节点的左子树只包含小于当前节点的数。</strong></li>
<li><strong>节点的右子树只包含大于当前节点的数。</strong></li>
<li><strong>左右子树也必须是二叉搜索树。</strong></li>
<li><strong>不存在两个节点具有相同的值。</strong></li>
</ol>
<span id="more"></span>

<h3 id="二分搜索树与普通二叉树的区别"><a href="#二分搜索树与普通二叉树的区别" class="headerlink" title="二分搜索树与普通二叉树的区别"></a>二分搜索树与普通二叉树的区别</h3><p>虽然二分搜索树是基于二叉树的，但它通过节点间键值的有序关系增加了额外的结构性，这使得二分搜索树在执行查找、插入和删除等操作时更为高效。相比之下，普通的二叉树不强制要求节点之间遵循特定的顺序，这可能导致上述操作的效率较低。</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a><strong>基本操作</strong></h3><ol>
<li><strong>查找</strong>：从根节点开始，递归或循环地比较当前节点的键与目标键，根据比较结果转向左子树或右子树。</li>
<li><strong>插入</strong>：从根节点开始，找到合适的叶子节点位置插入新节点，以保持二叉搜索树的有序性。</li>
<li><strong>删除</strong>：删除操作稍复杂，分三种情况：删除的节点是叶子节点、只有一个子节点、有两个子节点。</li>
<li><strong>遍历</strong>：常见的遍历方式包括中序遍历（In-order），前序遍历（Pre-order）和后序遍历（Post-order）。中序遍历二叉搜索树会按键的升序访问所有节点。</li>
</ol>
<h2 id="构建二分搜索树"><a href="#构建二分搜索树" class="headerlink" title="构建二分搜索树"></a>构建二分搜索树</h2><h3 id="基础元素Node"><a href="#基础元素Node" class="headerlink" title="基础元素Node"></a>基础元素 Node</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K, V&gt; {</span><br><span class="line">    <span class="keyword">public</span> K key;</span><br><span class="line">    <span class="keyword">public</span> V value;</span><br><span class="line">    <span class="keyword">public</span> Node&lt;K, V&gt; left, right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V value, Node&lt;K, V&gt; left, Node&lt;K, V&gt; right)</span> {</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V value)</span> {</span><br><span class="line">        <span class="built_in">this</span>(key, value, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Node&lt;K, V&gt; root;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BinarySearchTree</span><span class="params">()</span> {</span><br><span class="line">    root = <span class="literal">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>在二分搜索树中插入一个新节点的过程涉及到比较新节点的键与当前节点键的大小，以决定是将新节点插入到当前节点的左侧还是右侧。</p>
<ul>
<li><strong>步骤</strong>：</li>
</ul>
<ol>
<li>从根节点开始，比较新节点的键与当前节点的键。</li>
<li>如果新节点的键小于当前节点的键，则向左子树递归；如果大于，则向右子树递归。</li>
<li>如果当前节点的相应子树为空，则在这个位置插入新节点。</li>
</ol>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/202402201108577.png" alt="img"></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(K key, V value)</span> {</span><br><span class="line">    root = add(root, key, value);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>方法签名：向一颗二分搜索树中添加一个元素，并返回添加元素后的二分搜索树</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向以node为根的二分搜索树中添加键值对key value</span></span><br><span class="line"><span class="comment"> * 返回插入新结算后二分搜索树的根</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Node&lt;K, V&gt; <span class="title function_">add</span><span class="params">(Node&lt;K, V&gt; node, K key, V value)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        ++size;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K, V&gt;(key, value);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (key.compareTo(node.key) &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> node.left = add(node.left, key, value);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> node.right = add(node.right, key, value);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// key.compareTo(node.key) = 0 update</span></span><br><span class="line">        node.value = value;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>删除操作是二分搜索树中最复杂的操作之一，特别是当需要删除的节点既有左子树又有右子树时。</p>
<ul>
<li><strong>删除叶子节点</strong>：直接将父节点指向该叶子节点的链接设为 null。</li>
<li><strong>删除只有一个孩子的节点</strong>：将该节点的父节点指向该节点的唯一子节点。</li>
<li><strong>删除有两个孩子的节点</strong>：</li>
</ul>
<ol>
<li>找到该节点右子树中的最小节点（或左子树中的最大节点）。</li>
<li>用这个最小节点的键和值替换要删除的节点。</li>
<li>删除原最小节点。</li>
</ol>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/202402201109489.png" alt="img"></p>
<p><img data-src="https://cdn.nadav.com.cn/gh/nadav-cheung/img-repo/hexo-blog/202402201109112.png" alt="img"></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从二分搜索树中删除键为key的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(K key)</span> {</span><br><span class="line">    Node&lt;K, V&gt; removeNode = getNode(root, key);</span><br><span class="line">    <span class="keyword">if</span> (removeNode != <span class="literal">null</span>) {</span><br><span class="line">        root = remove(root, key);</span><br><span class="line">        <span class="keyword">return</span> removeNode.value;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>方法签名：删除二叉树 Node 中的 key，并返回删除后的 Node 二叉树</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> node 二叉树</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key  要移除的Key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 移除Key节点后的的二叉树</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> Node&lt;K, V&gt; <span class="title function_">remove</span><span class="params">(Node&lt;K, V&gt; node, K key)</span> {</span><br><span class="line">       <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">if</span> (key.compareTo(node.key) &lt; <span class="number">0</span>) {</span><br><span class="line">           node.left = remove(node.left, key);</span><br><span class="line">           <span class="keyword">return</span> node;</span><br><span class="line">       } <span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) &gt; <span class="number">0</span>) {</span><br><span class="line">           node.right = remove(node.right, key);</span><br><span class="line">           <span class="keyword">return</span> node;</span><br><span class="line">       } <span class="keyword">else</span> {</span><br><span class="line"></span><br><span class="line">           <span class="comment">//key.compareTo(node.key) = 0</span></span><br><span class="line">           <span class="keyword">if</span> (node.left == <span class="literal">null</span>) {</span><br><span class="line">               Node&lt;K, V&gt; rightNode = node.right;</span><br><span class="line">               node.right = <span class="literal">null</span>;</span><br><span class="line">               size--;</span><br><span class="line">               <span class="keyword">return</span> rightNode;</span><br><span class="line">           } <span class="keyword">else</span> <span class="keyword">if</span> (node.right == <span class="literal">null</span>) {</span><br><span class="line">               Node&lt;K, V&gt; leftNode = node.left;</span><br><span class="line">               node.left = <span class="literal">null</span>;</span><br><span class="line">               size--;</span><br><span class="line">               <span class="keyword">return</span> leftNode;</span><br><span class="line">           } <span class="keyword">else</span> {</span><br><span class="line">               Node&lt;K, V&gt; successor = minimum(node.right);</span><br><span class="line">               successor.left = node.left;</span><br><span class="line">               successor.right = remove(node.right, successor.key);</span><br><span class="line">               node.left = node.right = <span class="literal">null</span>;</span><br><span class="line">               <span class="keyword">return</span> successor;</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="常规方法"><a href="#常规方法" class="headerlink" title="常规方法"></a>常规方法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 如果此列表不包含任何元素，则返回true</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> {</span><br><span class="line">     <span class="keyword">return</span> getSize() == <span class="number">0</span>;</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 返回此队列中的元素数量</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> {</span><br><span class="line">     <span class="keyword">return</span> size;</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 查询二分搜索树中是否包含元素e</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(K key)</span> {</span><br><span class="line">     Node&lt;K, V&gt; node = getNode(root, key);</span><br><span class="line">     <span class="keyword">return</span> node != <span class="literal">null</span>;</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 查询二分搜索树中是否包含元素e</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> Node&lt;K, V&gt; <span class="title function_">getNode</span><span class="params">(Node&lt;K, V&gt; node, K key)</span> {</span><br><span class="line">     <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">     }</span><br><span class="line">     <span class="keyword">if</span> (key.compareTo(node.key) &lt; <span class="number">0</span>) {</span><br><span class="line">         <span class="keyword">return</span> getNode(node.left, key);</span><br><span class="line">     } <span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) &gt; <span class="number">0</span>) {</span><br><span class="line">         <span class="keyword">return</span> getNode(node.right, key);</span><br><span class="line">     } <span class="keyword">else</span> { <span class="comment">// key.compareTo(node.key) = 0</span></span><br><span class="line">         <span class="keyword">return</span> node;</span><br><span class="line">     }</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 查询二分搜索树中是否包含元素e</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> {</span><br><span class="line">     Node&lt;K, V&gt; node = getNode(root, key);</span><br><span class="line">     <span class="keyword">return</span> node != <span class="literal">null</span> ? node.value : <span class="literal">null</span>;</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将此列表中指定位置的元素替换为指定元素（可选操作）</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key      key</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> newValue 新值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(K key, V newValue)</span> {</span><br><span class="line">     Node&lt;K, V&gt; node = getNode(root, key);</span><br><span class="line">     <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">     }</span><br><span class="line">     node.value = newValue;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>遍历二分搜索树是访问树中每个节点的过程，以特定的顺序执行操作（如打印节点值）。遍历对于理解树的结构、调试代码和实现树的算法至关重要。</p>
<h3 id="前序遍历preOrder"><a href="#前序遍历preOrder" class="headerlink" title="前序遍历preOrder"></a>前序遍历 preOrder</h3><p>前序遍历首先访问根节点，然后递归地对左子树和右子树进行前序遍历。这种遍历方式适用于创建树的副本或打印树的结构。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> {</span><br><span class="line">    preOrder(root);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(Node&lt;K, V&gt; root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    System.out.println(root.key);</span><br><span class="line">    preOrder(root.left);</span><br><span class="line">    preOrder(root.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="使用栈实现非递归的前序遍历"><a href="#使用栈实现非递归的前序遍历" class="headerlink" title="使用栈实现非递归的前序遍历"></a>使用栈实现非递归的前序遍历</h3><ol>
<li>创建一个空栈。</li>
<li>将根节点压入栈中。</li>
<li>当栈不为空时，执行以下操作：</li>
</ol>
<ul>
<li>弹出栈顶元素，访问该元素。</li>
<li>将弹出节点的右子节点（如果有）压入栈中。</li>
<li>将弹出节点的左子节点（如果有）压入栈中。</li>
</ul>
<p>注意，右子节点先入栈，左子节点后入栈，这样可以保证左子节点先被访问。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrderNR</span><span class="params">()</span> {</span><br><span class="line">     <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     }</span><br><span class="line">     Deque&lt;Node&lt;K, V&gt;&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">     stack.push(root);</span><br><span class="line">     <span class="keyword">while</span> (!stack.isEmpty()) {</span><br><span class="line">         Node&lt;K, V&gt; node = stack.pop();</span><br><span class="line">         System.out.println(node.key);</span><br><span class="line">         <span class="keyword">if</span> (node.right != <span class="literal">null</span>) {</span><br><span class="line">             stack.push(node.right);</span><br><span class="line">         }</span><br><span class="line">         <span class="keyword">if</span> (node.left != <span class="literal">null</span>) {</span><br><span class="line">             stack.push(node.left);</span><br><span class="line">         }</span><br><span class="line">     }</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="中序遍历inOrder"><a href="#中序遍历inOrder" class="headerlink" title="中序遍历inOrder"></a>中序遍历 inOrder</h3><p>中序遍历首先递归地对左子树进行中序遍历，然后访问根节点，最后递归地对右子树进行中序遍历。中序遍历二分搜索树可以得到一个有序的键序列，是二分搜索树最常用的遍历方式。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">()</span> {</span><br><span class="line">    inOrder(root);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(Node&lt;K, V&gt; root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    inOrder(root.left);</span><br><span class="line">    System.out.println(root.key);</span><br><span class="line">    inOrder(root.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="使用栈实现非递归的中序遍历"><a href="#使用栈实现非递归的中序遍历" class="headerlink" title="使用栈实现非递归的中序遍历"></a>使用栈实现非递归的中序遍历</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrderNR</span><span class="params">()</span> {</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      }</span><br><span class="line">      Deque&lt;Node&lt;K, V&gt;&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">      Node&lt;K, V&gt; cur = root;</span><br><span class="line">      <span class="keyword">while</span> (cur != <span class="literal">null</span> || !stack.isEmpty()) {</span><br><span class="line">          <span class="keyword">while</span> (cur != <span class="literal">null</span>) {</span><br><span class="line">              stack.push(cur);</span><br><span class="line">              cur = cur.left;</span><br><span class="line">          }</span><br><span class="line">          cur = stack.pop();</span><br><span class="line">          System.out.println(cur.key);</span><br><span class="line">          cur = cur.right;</span><br><span class="line">      }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="后序遍历-postOrder"><a href="#后序遍历-postOrder" class="headerlink" title="后序遍历 postOrder"></a>后序遍历 postOrder</h3><p>后序遍历首先递归地对左子树和右子树进行后序遍历，然后访问根节点。后序遍历适用于递归释放或删除树的节点，因为它确保节点在其子节点被处理后才被访问。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span> {</span><br><span class="line">    postOrder(root);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(Node&lt;K, V&gt; root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    postOrder(root.left);</span><br><span class="line">    postOrder(root.right);</span><br><span class="line">    System.out.println(root.key);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="使用栈实现非递归的后序遍历"><a href="#使用栈实现非递归的后序遍历" class="headerlink" title="使用栈实现非递归的后序遍历"></a>使用栈实现非递归的后序遍历</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrderNR</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    Deque&lt;Node&lt;K, V&gt;&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Deque&lt;Node&lt;K, V&gt;&gt; output = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) {</span><br><span class="line">        Node&lt;K, V&gt; node = stack.pop();</span><br><span class="line">        output.push(node);</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) {</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) {</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (!output.isEmpty()) {</span><br><span class="line">        System.out.println(output.pop().key);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>层序遍历（广度优先搜索）按照树的层次从上到下遍历树的节点，通常使用队列来实现。层序遍历用于寻找最短路径、进行层次分析或在树中按层次顺序执行操作。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">levelOrder</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    Queue&lt;Node&lt;K, V&gt;&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">        Node&lt;K, V&gt; node = queue.poll();</span><br><span class="line">        System.out.println(node.key);</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) {</span><br><span class="line">            queue.offer(node.left);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) {</span><br><span class="line">            queue.offer(node.right);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>二分搜索树以其独特的结构和操作效率，在众多领域内发挥着重要作用。以下是一些主要的应用场景：</p>
<h3 id="构建动态数据结构"><a href="#构建动态数据结构" class="headerlink" title="构建动态数据结构"></a>构建动态数据结构</h3><p>二分搜索树能够动态地插入和删除节点，使其成为实现各种动态数据结构（如集合、映射和优先队列）的理想选择。通过二分搜索树，可以在对数时间内完成添加、查询和删除等操作，大大提高了数据处理的效率。</p>
<h3 id="实现查找表"><a href="#实现查找表" class="headerlink" title="实现查找表"></a>实现查找表</h3><p>二分搜索树特别适合用于实现查找表，其中包括键值对的存储和检索。由于其有序性，二分搜索树可以快速定位到一个键，并检索或更新与之关联的值。这在数据库管理系统和文件系统中尤其有用。</p>
<h3 id="算法中的应用"><a href="#算法中的应用" class="headerlink" title="算法中的应用"></a>算法中的应用</h3><p>在算法设计中，二分搜索树用于解决诸如范围查询、排序和近似匹配等问题。例如，通过中序遍历二分搜索树，可以高效地实现数据的排序。此外，二分搜索树也常用于实现各种高级算法，如动态顺序统计、区间树和伸展树等。</p>
<h3 id="支持范围操作"><a href="#支持范围操作" class="headerlink" title="支持范围操作"></a>支持范围操作</h3><p>二分搜索树支持高效的范围搜索操作，可以快速找到给定范围内的所有键。这在需要对数据进行分段分析或查询特定区间内的数据时特别有用，如在报告生成和数据分析应用中。</p>
<h3 id="高级话题和优化"><a href="#高级话题和优化" class="headerlink" title="高级话题和优化"></a>高级话题和优化</h3><p>虽然标准的二分搜索树在许多情况下表现良好，但在最坏情况下它可能会退化成一个链表，导致操作效率大幅下降。为了解决这个问题，研究人员提出了多种平衡二叉搜索树，如 AVL 树、红黑树和 B 树等。这些树通过在树操作中加入旋转和重组操作，保证了树的平衡性，从而确保了操作的最坏情况时间复杂度为对数级别。此外，二分搜索树的性能也可以通过各种优化策略，如节点缓存、懒惰删除和树的重构等，进一步提高。</p>
<h2 id="github项目"><a href="#github项目" class="headerlink" title="github项目"></a><a href="https://github.com/nadav-cheung/algorithm">github 项目</a></h2>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>二分搜索树</category>
      </categories>
      <tags>
        <tag>BST</tag>
        <tag>二分搜索树</tag>
      </tags>
  </entry>
</search>
